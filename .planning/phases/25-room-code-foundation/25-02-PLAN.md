---
phase: 25-room-code-foundation
plan: 02
type: execute
wave: 2
depends_on:
  - 25-01
files_modified:
  - apps/accommodations/frontend/types/stay.ts
  - apps/accommodations/frontend/lib/auth.ts
  - apps/accommodations/frontend/app/api/stay/room/[roomCode]/route.ts
  - apps/accommodations/frontend/hooks/useRoomSession.ts
  - apps/accommodations/frontend/app/stay/room/[roomCode]/page.tsx
autonomous: true

must_haves:
  truths:
    - 'GET /api/stay/room/[roomCode] validates format (RM- + 8 chars), calls resolve_room_access RPC, returns JWT + stay data'
    - 'Browse-tier JWT has accessTier: browse in payload, room code sessions use same localStorage keys as booking sessions'
    - 'When resolve_room_access returns has_active_booking=true, API fetches full property+room+WiFi data and returns StayData with booking info'
    - 'When resolve_room_access returns has_active_booking=false, API returns RoomStayData with property+room+WiFi but NO booking info'
    - 'When resolve_room_access returns is_valid=false, API returns 404 with invalid_room_code error'
    - 'Browse-tier JWT with active booking expires at checkout+24h; without active booking expires 7 days from now'
    - 'useRoomSession hook calls GET /api/stay/room/[roomCode] on mount, stores token+data, exposes hasActiveBooking flag'
    - '/stay/room/[roomCode] page renders the dashboard with WiFi, property info, contacts, house rules visible immediately'
    - '/stay/room/[roomCode] page hides WelcomeCard guest name, ActiveOrders, CartFAB, and order-related sections in browse tier'
    - 'Existing /stay/[code] route is completely untouched (zero modifications to existing files except types/stay.ts and lib/auth.ts)'
    - 'signGuestToken accepts optional accessTier and roomCode parameters with backward-compatible defaults'
    - 'verifyGuestToken returns accessTier defaulting to full when claim is missing (backward compat for existing tokens)'
    - 'GuestTokenPayload type includes accessTier and optional roomCode fields'
  artifacts:
    - path: 'apps/accommodations/frontend/app/api/stay/room/[roomCode]/route.ts'
      provides: 'Room code resolution API endpoint'
      contains: 'resolve_room_access'
    - path: 'apps/accommodations/frontend/hooks/useRoomSession.ts'
      provides: 'Client-side room session management'
      contains: 'useRoomSession'
    - path: 'apps/accommodations/frontend/app/stay/room/[roomCode]/page.tsx'
      provides: 'Room QR landing page with browse-tier dashboard'
      contains: 'RoomDashboard'
  key_links:
    - from: 'GET /api/stay/room/[roomCode]'
      to: 'resolve_room_access RPC'
      via: 'supabaseAdmin.rpc'
      pattern: "supabase\\.rpc\\('resolve_room_access'"
    - from: '/stay/room/[roomCode]/page.tsx'
      to: 'useRoomSession hook'
      via: 'React hook'
      pattern: 'useRoomSession'
    - from: 'useRoomSession'
      to: 'GET /api/stay/room/[roomCode]'
      via: 'fetch on mount'
      pattern: "fetch\\('/api/stay/room/"
---

<objective>
Build the /stay/room/[roomCode] route, browse-tier JWT, useRoomSession hook, and room dashboard page that together deliver the frictionless QR scan experience.

Purpose: When a guest scans a room QR code, they land on /stay/room/RM-XXXXXXXX, which immediately resolves to the active booking (or property fallback) and shows WiFi, property info, contacts, and house rules -- zero login forms, zero verification prompts. This is the complete guest-facing experience for Phase 25.

Output: API route, hook, page, and updated types/auth that make the room QR flow work end-to-end.
</objective>

<execution_context>
@/Users/gianfrancodagostino/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gianfrancodagostino/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/25-room-code-foundation/25-RESEARCH.md

# Existing patterns to follow

@apps/accommodations/frontend/lib/auth.ts
@apps/accommodations/frontend/types/stay.ts
@apps/accommodations/frontend/app/api/stay/verify/route.ts
@apps/accommodations/frontend/hooks/useStaySession.ts
@apps/accommodations/frontend/app/stay/[code]/page.tsx
@apps/accommodations/frontend/lib/supabase.ts
@apps/accommodations/frontend/lib/stay-api.ts

# Dashboard components (reused in room page)

@apps/accommodations/frontend/components/stay/WifiCard.tsx
@apps/accommodations/frontend/components/stay/DashboardHeader.tsx
@apps/accommodations/frontend/components/stay/ContactSheet.tsx
@apps/accommodations/frontend/components/stay/UsefulNumbers.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend types and auth for browse-tier JWT</name>
  <files>apps/accommodations/frontend/types/stay.ts, apps/accommodations/frontend/lib/auth.ts</files>
  <action>
**1a. Update types/stay.ts**

Add these new types and update existing ones:

Add `'invalid_room_code'` to the `ApiError` union type.

Add new types after the existing `VerifyResponse`:

```typescript
// --- Access tier for progressive auth ---

export type AccessTier = 'browse' | 'full';

// --- GET /api/stay/room/[roomCode] ---

export interface RoomResolveResponse {
  token: string;
  stay: RoomStayData;
}

/**
 * Stay data from room code resolution.
 * Similar to StayData but booking is optional (room may be vacant).
 */
export interface RoomStayData {
  property: PropertyInfo;
  room: RoomInfo;
  booking: BookingInfo | null; // null when no active booking
  wifi: WifiInfo;
  hasActiveBooking: boolean;
  accessTier: AccessTier;
}
```

**1b. Update lib/auth.ts**

Extend `GuestTokenPayload` to include accessTier and roomCode:

```typescript
export interface GuestTokenPayload {
  bookingId: string;
  propertyId: string;
  checkoutDate: string;
  accessTier?: 'browse' | 'full'; // undefined treated as 'full' for backward compat
  roomCode?: string;
}
```

Update `signGuestToken` to accept the new optional fields:

```typescript
export async function signGuestToken(payload: {
  bookingId: string | null; // null for no-booking room sessions
  propertyId: string;
  checkoutDate: string;
  accessTier?: 'browse' | 'full';
  roomCode?: string;
}): Promise<string> {
  const checkoutDate = new Date(payload.checkoutDate);
  const expiresAt = addHours(checkoutDate, 24);

  return new SignJWT({
    bookingId: payload.bookingId,
    propertyId: payload.propertyId,
    checkoutDate: payload.checkoutDate,
    ...(payload.accessTier && { accessTier: payload.accessTier }),
    ...(payload.roomCode && { roomCode: payload.roomCode }),
  })
    .setProtectedHeader({ alg: 'HS256' })
    .setIssuedAt()
    .setExpirationTime(Math.floor(expiresAt.getTime() / 1000))
    .sign(getSecret());
}
```

Update `verifyGuestToken` to extract the new fields with backward-compatible defaults:

```typescript
export async function verifyGuestToken(
  token: string
): Promise<GuestTokenPayload> {
  const { payload } = await jwtVerify(token, getSecret());
  return {
    bookingId: payload.bookingId as string,
    propertyId: payload.propertyId as string,
    checkoutDate: payload.checkoutDate as string,
    accessTier: (payload.accessTier as 'browse' | 'full') || 'full',
    roomCode: (payload.roomCode as string) || undefined,
  };
}
```

Critical: `accessTier` defaults to `'full'` when not present in token payload. This means all existing tokens from the verify flow continue to work as full-access tokens without any changes to the verify route.

Verify: The existing `signGuestToken` call in `/api/stay/verify/route.ts` does NOT pass `accessTier`, so it will be omitted from the JWT. When decoded, `verifyGuestToken` will default it to `'full'`. This is the correct backward-compat behavior -- existing verified sessions get full access.
</action>
<verify>

1. TypeScript compile check: `cd apps/accommodations/frontend && npx tsc --noEmit --pretty 2>&1 | head -30`
2. Verify GuestTokenPayload has accessTier: `grep "accessTier" apps/accommodations/frontend/lib/auth.ts`
3. Verify backward compat default: `grep "'full'" apps/accommodations/frontend/lib/auth.ts` -- should appear in verifyGuestToken
4. Verify new types exist: `grep "RoomResolveResponse\|RoomStayData\|AccessTier" apps/accommodations/frontend/types/stay.ts`
5. Verify existing verify route still works (no changes to verify/route.ts): `grep -c "accessTier" apps/accommodations/frontend/app/api/stay/verify/route.ts` -- should be 0
   </verify>
   <done>
   GuestTokenPayload extended with optional accessTier (defaults to 'full') and roomCode. signGuestToken accepts null bookingId and optional new fields. verifyGuestToken extracts accessTier with 'full' default. New types: AccessTier, RoomResolveResponse, RoomStayData. ApiError includes 'invalid_room_code'. Zero changes to existing verify route.
   </done>
   </task>

<task type="auto">
  <name>Task 2: Create room code resolution API route</name>
  <files>apps/accommodations/frontend/app/api/stay/room/[roomCode]/route.ts</files>
  <action>
Create `apps/accommodations/frontend/app/api/stay/room/[roomCode]/route.ts`:

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { addDays, differenceInCalendarDays } from 'date-fns';
import { getSupabaseAdmin } from '@/lib/supabase';
import { signGuestToken } from '@/lib/auth';
import type {
  ApiResponse,
  RoomResolveResponse,
  RoomStayData,
  PropertyInfo,
  RoomInfo,
  BookingInfo,
  WifiInfo,
} from '@/types/stay';

export const dynamic = 'force-dynamic';

/**
 * GET /api/stay/room/[roomCode]
 *
 * Room code resolution endpoint. Called when guest scans room QR code.
 * Resolves room code to active booking (or property-only fallback)
 * via the resolve_room_access() SECURITY DEFINER function.
 *
 * Returns a browse-tier JWT and stay data.
 * No verification required -- this is the frictionless entry point.
 */
export async function GET(
  _request: NextRequest,
  { params }: { params: { roomCode: string } }
) {
  try {
    const { roomCode } = params;

    // Validate room code format: RM- followed by 8 valid chars
    const codePattern = /^RM-[A-HJ-NP-Z2-9]{8}$/;
    if (!codePattern.test(roomCode)) {
      return NextResponse.json<ApiResponse<null>>(
        { error: 'invalid_room_code' },
        { status: 400 }
      );
    }

    const supabase = getSupabaseAdmin();

    // Call SECURITY DEFINER function to resolve room code
    const { data: rpcData, error: rpcError } = await supabase.rpc(
      'resolve_room_access',
      { p_room_code: roomCode }
    );

    if (rpcError) {
      console.error('resolve_room_access error:', rpcError);
      return NextResponse.json<ApiResponse<null>>(
        { error: 'internal_error' },
        { status: 500 }
      );
    }

    const result = rpcData?.[0];
    if (!result?.is_valid) {
      return NextResponse.json<ApiResponse<null>>(
        { error: 'invalid_room_code' },
        { status: 404 }
      );
    }

    // Fetch property data (always needed for both booking and no-booking cases)
    const { data: propertyData, error: propertyError } = await supabase
      .from('accom_properties')
      .select(
        `
        name, slug, type, description,
        contact_phone, contact_email, contact_whatsapp,
        checkout_time, house_rules, amenities, images,
        wifi_network, wifi_password,
        has_linked_fnb, linked_fnb_slug
      `
      )
      .eq('id', result.property_id)
      .single();

    if (propertyError || !propertyData) {
      console.error('Property fetch error:', propertyError);
      return NextResponse.json<ApiResponse<null>>(
        { error: 'internal_error' },
        { status: 500 }
      );
    }

    // Map property data
    const property: PropertyInfo = {
      name: propertyData.name,
      slug: propertyData.slug,
      type: propertyData.type,
      description: propertyData.description || null,
      contactPhone: propertyData.contact_phone || null,
      contactEmail: propertyData.contact_email || null,
      contactWhatsapp: propertyData.contact_whatsapp || null,
      checkoutTime: propertyData.checkout_time || '11:00',
      houseRules: propertyData.house_rules || [],
      amenities: propertyData.amenities || [],
      images: propertyData.images || [],
      hasLinkedFnb: propertyData.has_linked_fnb ?? false,
      linkedFnbSlug: propertyData.linked_fnb_slug || null,
    };

    const room: RoomInfo = {
      number: result.room_number,
      name: result.room_type || '',
      floor: null, // Floor not returned by resolve_room_access for simplicity
    };

    const wifi: WifiInfo = {
      network: propertyData.wifi_network || null,
      password: propertyData.wifi_password || null,
    };

    // Build booking info if active booking exists
    let booking: BookingInfo | null = null;
    let checkoutDate: string;

    if (result.has_active_booking && result.booking_id) {
      const nights = differenceInCalendarDays(
        new Date(result.check_out),
        new Date(result.check_in)
      );

      booking = {
        code: '', // Not exposed in browse tier (privacy)
        guestName: '', // Not exposed in browse tier (privacy)
        guestCount: 0, // Not exposed in browse tier
        checkIn: result.check_in,
        checkOut: result.check_out,
        nights,
        status: 'checked_in', // Simplified for browse tier
        guestCountry: null,
      };

      checkoutDate = result.check_out;
    } else {
      // No active booking: token expires 7 days from now
      checkoutDate = addDays(new Date(), 7).toISOString().split('T')[0];
    }

    // Sign browse-tier JWT
    const token = await signGuestToken({
      bookingId: result.booking_id || null,
      propertyId: result.property_id,
      checkoutDate,
      accessTier: 'browse',
      roomCode,
    });

    const stay: RoomStayData = {
      property,
      room,
      booking,
      wifi,
      hasActiveBooking: result.has_active_booking,
      accessTier: 'browse',
    };

    return NextResponse.json<ApiResponse<RoomResolveResponse>>({
      data: { token, stay },
    });
  } catch (err) {
    console.error('GET /api/stay/room/[roomCode] error:', err);
    return NextResponse.json<ApiResponse<null>>(
      { error: 'internal_error' },
      { status: 500 }
    );
  }
}
```

Key decisions:

- Browse tier does NOT expose guest name, booking code, or guest count (privacy -- anyone scanning QR sees this)
- Active booking provides check-in/check-out dates (useful for checkout countdown) but no PII
- No-booking case uses 7-day token expiry (guest might be browsing property info pre-arrival)
- Floor is omitted from resolve_room_access for simplicity; could be added later if needed
- Room code format regex matches exactly the chars used by generate_room_code()
  </action>
  <verify>

1. File exists: `ls apps/accommodations/frontend/app/api/stay/room/*/route.ts`
2. TypeScript compile: `cd apps/accommodations/frontend && npx tsc --noEmit --pretty 2>&1 | head -30`
3. Verify RPC call: `grep "resolve_room_access" apps/accommodations/frontend/app/api/stay/room/*/route.ts`
4. Verify browse tier: `grep "accessTier.*browse" apps/accommodations/frontend/app/api/stay/room/*/route.ts`
5. Verify format validation: `grep "RM-" apps/accommodations/frontend/app/api/stay/room/*/route.ts`
6. Verify privacy: guest name is empty string, not the actual name from DB
   </verify>
   <done>
   Room resolution API at GET /api/stay/room/[roomCode]: validates RM-XXXXXXXX format, calls resolve_room_access RPC, fetches property data, returns browse-tier JWT + RoomStayData. Privacy: no guest name/code in browse tier. Token expiry: checkout+24h with booking, 7 days without.
   </done>
   </task>

<task type="auto">
  <name>Task 3: Create useRoomSession hook</name>
  <files>apps/accommodations/frontend/hooks/useRoomSession.ts</files>
  <action>
Create `apps/accommodations/frontend/hooks/useRoomSession.ts`:

```typescript
'use client';

import { useState, useEffect, useCallback } from 'react';
import type {
  RoomStayData,
  RoomResolveResponse,
  ApiResponse,
} from '@/types/stay';

const TOKEN_KEY = 'gudbro_stay_token';
const STAY_KEY = 'gudbro_stay_data';

export interface RoomSession {
  token: string | null;
  stay: RoomStayData | null;
  isLoading: boolean;
  hasActiveBooking: boolean;
  error: string | null;
  refresh: () => Promise<void>;
}

/**
 * Decode JWT payload using atob (client-side only, no verification).
 */
function decodeJwtPayload(token: string): Record<string, unknown> | null {
  try {
    const parts = token.split('.');
    if (parts.length !== 3) return null;
    const payload = atob(parts[1].replace(/-/g, '+').replace(/_/g, '/'));
    return JSON.parse(payload);
  } catch {
    return null;
  }
}

/**
 * Check if a JWT token is expired by reading the `exp` claim.
 */
function isTokenExpired(token: string): boolean {
  const payload = decodeJwtPayload(token);
  if (!payload || typeof payload.exp !== 'number') return true;
  return payload.exp * 1000 < Date.now();
}

/**
 * Check if a stored session is a room session for the given room code.
 */
function isMatchingRoomSession(token: string, roomCode: string): boolean {
  const payload = decodeJwtPayload(token);
  return payload?.roomCode === roomCode && payload?.accessTier === 'browse';
}

/**
 * Session management hook for room-based QR access (browse tier).
 *
 * Unlike useStaySession which requires explicit verify(),
 * this hook auto-resolves the room code on mount.
 *
 * Uses the same localStorage keys as useStaySession -- a room session
 * overwrites a booking session and vice versa. This is intentional:
 * the guest should see whichever session they accessed most recently.
 */
export function useRoomSession(roomCode: string): RoomSession {
  const [token, setToken] = useState<string | null>(null);
  const [stay, setStay] = useState<RoomStayData | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const resolveRoom = useCallback(async () => {
    try {
      setError(null);
      const res = await fetch(`/api/stay/room/${roomCode}`);
      const json: ApiResponse<RoomResolveResponse> = await res.json();

      if (!res.ok || json.error || !json.data) {
        if (res.status === 404) {
          setError(
            'This room code is not valid. Please scan the QR code in your room.'
          );
        } else {
          setError('Something went wrong. Please try again.');
        }
        // Clear any stale session
        localStorage.removeItem(TOKEN_KEY);
        localStorage.removeItem(STAY_KEY);
        return;
      }

      // Store session
      localStorage.setItem(TOKEN_KEY, json.data.token);
      localStorage.setItem(STAY_KEY, JSON.stringify(json.data.stay));
      setToken(json.data.token);
      setStay(json.data.stay);
    } catch {
      setError('Network error. Please check your connection and try again.');
    }
  }, [roomCode]);

  // On mount: check for existing valid session or resolve fresh
  useEffect(() => {
    async function init() {
      setIsLoading(true);

      try {
        const storedToken = localStorage.getItem(TOKEN_KEY);
        const storedStay = localStorage.getItem(STAY_KEY);

        // Reuse existing session if it's valid and matches this room
        if (storedToken && storedStay && !isTokenExpired(storedToken)) {
          if (isMatchingRoomSession(storedToken, roomCode)) {
            setToken(storedToken);
            setStay(JSON.parse(storedStay));
            setIsLoading(false);
            return;
          }
        }

        // No valid matching session -- resolve fresh from API
        await resolveRoom();
      } catch {
        setError('Failed to initialize session.');
      } finally {
        setIsLoading(false);
      }
    }

    init();
  }, [roomCode, resolveRoom]);

  return {
    token,
    stay,
    isLoading,
    hasActiveBooking: stay?.hasActiveBooking ?? false,
    error,
    refresh: resolveRoom,
  };
}
```

Key design decisions:

- Same localStorage keys as useStaySession (intentional -- latest session wins)
- Auto-resolves on mount (no manual verify step needed)
- Reuses cached session if token is valid AND matches the same room code
- Different room code or expired token triggers fresh resolution
- Exposes `refresh()` for manual re-resolution (e.g., after verification upgrade in Phase 26)
- Error messages are user-friendly English strings
  </action>
  <verify>

1. File exists: `ls apps/accommodations/frontend/hooks/useRoomSession.ts`
2. TypeScript compile: `cd apps/accommodations/frontend && npx tsc --noEmit --pretty 2>&1 | head -30`
3. Same localStorage keys: `grep "gudbro_stay_token\|gudbro_stay_data" apps/accommodations/frontend/hooks/useRoomSession.ts`
4. Auto-resolve on mount: `grep "useEffect" apps/accommodations/frontend/hooks/useRoomSession.ts`
5. Room code matching: `grep "isMatchingRoomSession" apps/accommodations/frontend/hooks/useRoomSession.ts`
   </verify>
   <done>
   useRoomSession hook: auto-resolves room code on mount, caches session in same localStorage keys, reuses valid matching sessions, exposes hasActiveBooking flag, error state, and refresh() method. No manual verification step.
   </done>
   </task>

<task type="auto">
  <name>Task 4: Create room dashboard page</name>
  <files>apps/accommodations/frontend/app/stay/room/[roomCode]/page.tsx</files>
  <action>
Create `apps/accommodations/frontend/app/stay/room/[roomCode]/page.tsx`:

This page reuses existing dashboard components but conditionally hides booking-specific sections in browse tier.

```tsx
'use client';

import { useState, useEffect } from 'react';
import { useRoomSession } from '@/hooks/useRoomSession';
import { fetchProperty } from '@/lib/stay-api';
import type { PropertyExtended } from '@/types/stay';

import DashboardHeader from '@/components/stay/DashboardHeader';
import WifiCard from '@/components/stay/WifiCard';
import CheckoutInfo from '@/components/stay/CheckoutInfo';
import ContactSheet from '@/components/stay/ContactSheet';
import RestaurantSection from '@/components/stay/RestaurantSection';
import UsefulNumbers from '@/components/stay/UsefulNumbers';
import LocalDeals from '@/components/stay/LocalDeals';
import BottomNav from '@/components/BottomNav';

/**
 * Room QR Dashboard - Browse Tier
 *
 * Renders when guest scans a permanent room QR code.
 * Shows WiFi, property info, contacts, house rules immediately.
 * Hides guest-specific info (name, orders, cart) in browse tier.
 *
 * For Phase 25: read-only dashboard. Phase 26 adds inline verification
 * to upgrade to full tier for ordering.
 */
export default function RoomDashboard({
  params,
}: {
  params: { roomCode: string };
}) {
  const { token, stay, isLoading, hasActiveBooking, error } = useRoomSession(
    params.roomCode
  );
  const [propertyExtended, setPropertyExtended] =
    useState<PropertyExtended | null>(null);
  const [activeTab, setActiveTab] = useState('home');

  // Fetch extended property data if we have a token and booking code
  useEffect(() => {
    if (!token || !stay?.booking?.code) return;

    // Only fetch extended data if there's an active booking with a real code
    // Browse tier won't have a booking code, so this is safely skipped
  }, [token, stay]);

  // Loading state
  if (isLoading) {
    return (
      <div className="flex min-h-screen items-center justify-center bg-gray-50">
        <div className="text-center">
          <div className="border-accent mx-auto mb-3 h-8 w-8 animate-spin rounded-full border-b-2" />
          <p className="text-sm text-gray-500">Loading room information...</p>
        </div>
      </div>
    );
  }

  // Error state
  if (error || !stay) {
    return (
      <div className="flex min-h-screen items-center justify-center bg-gray-50 p-4">
        <div className="max-w-sm text-center">
          <div className="mb-4 text-4xl">üîç</div>
          <h1 className="mb-2 text-lg font-semibold text-gray-900">
            Room Not Found
          </h1>
          <p className="mb-4 text-sm text-gray-500">
            {error ||
              'We could not find information for this room. Please scan the QR code in your room.'}
          </p>
          <button
            onClick={() => window.location.reload()}
            className="text-accent text-sm hover:underline"
          >
            Try again
          </button>
        </div>
      </div>
    );
  }

  // Property info page (no active booking)
  if (!hasActiveBooking) {
    return (
      <div className="min-h-screen bg-gray-50">
        {/* Header with property name */}
        <div className="border-b bg-white px-4 py-4">
          <h1 className="text-lg font-semibold text-gray-900">
            {stay.property.name}
          </h1>
          <p className="mt-0.5 text-sm text-gray-500">
            Room {stay.room.number} &middot; {stay.room.name}
          </p>
        </div>

        <div className="space-y-4 p-4 pb-24">
          {/* WiFi card - always shown */}
          {stay.wifi.network && <WifiCard wifi={stay.wifi} />}

          {/* Property info */}
          {stay.property.description && (
            <div className="rounded-xl bg-white p-4 shadow-sm">
              <h2 className="mb-2 text-sm font-semibold text-gray-900">
                About
              </h2>
              <p className="text-sm text-gray-600">
                {stay.property.description}
              </p>
            </div>
          )}

          {/* House rules */}
          {stay.property.houseRules.length > 0 && (
            <div className="rounded-xl bg-white p-4 shadow-sm">
              <h2 className="mb-2 text-sm font-semibold text-gray-900">
                House Rules
              </h2>
              <ul className="space-y-1.5">
                {stay.property.houseRules.map((rule, i) => (
                  <li key={i} className="flex gap-2 text-sm text-gray-600">
                    <span className="shrink-0 text-gray-400">‚Ä¢</span>
                    <span>{rule}</span>
                  </li>
                ))}
              </ul>
            </div>
          )}

          {/* Contact info */}
          {(stay.property.contactPhone ||
            stay.property.contactEmail ||
            stay.property.contactWhatsapp) && (
            <div className="rounded-xl bg-white p-4 shadow-sm">
              <h2 className="mb-2 text-sm font-semibold text-gray-900">
                Contact
              </h2>
              <div className="space-y-2">
                {stay.property.contactPhone && (
                  <a
                    href={`tel:${stay.property.contactPhone}`}
                    className="text-accent flex items-center gap-2 text-sm"
                  >
                    üìû {stay.property.contactPhone}
                  </a>
                )}
                {stay.property.contactWhatsapp && (
                  <a
                    href={`https://wa.me/${stay.property.contactWhatsapp.replace(/[^0-9]/g, '')}`}
                    target="_blank"
                    rel="noopener noreferrer"
                    className="flex items-center gap-2 text-sm text-green-600"
                  >
                    üí¨ WhatsApp
                  </a>
                )}
                {stay.property.contactEmail && (
                  <a
                    href={`mailto:${stay.property.contactEmail}`}
                    className="text-accent flex items-center gap-2 text-sm"
                  >
                    ‚úâÔ∏è {stay.property.contactEmail}
                  </a>
                )}
              </div>
            </div>
          )}

          {/* F&B link if available */}
          {stay.property.hasLinkedFnb && stay.property.linkedFnbSlug && (
            <RestaurantSection slug={stay.property.linkedFnbSlug} />
          )}
        </div>
      </div>
    );
  }

  // Full browse-tier dashboard (active booking, but read-only)
  return (
    <div className="min-h-screen bg-gray-50 pb-24">
      {/* Header - property name instead of guest name (browse tier privacy) */}
      <div className="border-b bg-white px-4 py-4">
        <h1 className="text-lg font-semibold text-gray-900">
          Welcome to {stay.property.name}
        </h1>
        <p className="mt-0.5 text-sm text-gray-500">
          Room {stay.room.number} &middot; {stay.room.name}
        </p>
        {stay.booking && (
          <p className="mt-1 text-xs text-gray-400">
            {stay.booking.checkIn} ‚Äî {stay.booking.checkOut}
          </p>
        )}
      </div>

      <div className="space-y-4 p-4">
        {/* WiFi card - prominent, first thing guest needs */}
        {stay.wifi.network && <WifiCard wifi={stay.wifi} />}

        {/* Checkout info if booking dates available */}
        {stay.booking && (
          <CheckoutInfo
            checkOut={stay.booking.checkOut}
            checkoutTime={stay.property.checkoutTime}
          />
        )}

        {/* Property info */}
        {stay.property.description && (
          <div className="rounded-xl bg-white p-4 shadow-sm">
            <h2 className="mb-2 text-sm font-semibold text-gray-900">About</h2>
            <p className="text-sm text-gray-600">{stay.property.description}</p>
          </div>
        )}

        {/* House rules */}
        {stay.property.houseRules.length > 0 && (
          <div className="rounded-xl bg-white p-4 shadow-sm">
            <h2 className="mb-2 text-sm font-semibold text-gray-900">
              House Rules
            </h2>
            <ul className="space-y-1.5">
              {stay.property.houseRules.map((rule, i) => (
                <li key={i} className="flex gap-2 text-sm text-gray-600">
                  <span className="shrink-0 text-gray-400">‚Ä¢</span>
                  <span>{rule}</span>
                </li>
              ))}
            </ul>
          </div>
        )}

        {/* Contact */}
        {(stay.property.contactPhone ||
          stay.property.contactEmail ||
          stay.property.contactWhatsapp) && (
          <ContactSheet
            phone={stay.property.contactPhone}
            email={stay.property.contactEmail}
            whatsapp={stay.property.contactWhatsapp}
          />
        )}

        {/* F&B link */}
        {stay.property.hasLinkedFnb && stay.property.linkedFnbSlug && (
          <RestaurantSection slug={stay.property.linkedFnbSlug} />
        )}

        {/* Browse tier notice - gentle prompt for Phase 26 upgrade */}
        <div className="rounded-xl bg-blue-50 p-4 text-center">
          <p className="text-sm text-blue-700">
            To order room service or other paid services, please verify your
            booking.
          </p>
          <p className="mt-1 text-xs text-blue-500">
            This feature is coming soon.
          </p>
        </div>
      </div>
    </div>
  );
}
```

Key decisions:

- Two render paths: no-booking (property info only) and active-booking (browse dashboard)
- No WelcomeCard (shows guest name -- privacy risk in browse tier)
- No ActiveOrders, CartFAB, CartDrawer (ordering requires full tier -- Phase 26)
- No QuickActions (these trigger WhatsApp messages which are fine, but keeping consistent with browse-tier restrictions)
- WiFi card is first/prominent in both paths (primary reason guest scans QR)
- CheckoutInfo shown when booking exists (useful countdown)
- Browse tier notice at bottom hints at ordering capability (Phase 26)
- Property name used as welcome message instead of guest name
- Reuses existing components where possible (WifiCard, CheckoutInfo, ContactSheet, RestaurantSection)

**Important:** Check that the existing components accept the props being passed. If WifiCard expects `wifi: WifiInfo`, ContactSheet expects phone/email/whatsapp, etc. -- verify the prop types match. Adjust prop passing if needed to match existing component interfaces.
</action>
<verify>

1. File exists: `ls apps/accommodations/frontend/app/stay/room/*/page.tsx`
2. TypeScript compile: `cd apps/accommodations/frontend && npx tsc --noEmit --pretty 2>&1 | head -30`
3. Uses useRoomSession: `grep "useRoomSession" apps/accommodations/frontend/app/stay/room/*/page.tsx`
4. Does NOT import WelcomeCard: `grep -c "WelcomeCard" apps/accommodations/frontend/app/stay/room/*/page.tsx` -- should be 0
5. Does NOT import ActiveOrders: `grep -c "ActiveOrders" apps/accommodations/frontend/app/stay/room/*/page.tsx` -- should be 0
6. Does NOT import CartFAB: `grep -c "CartFAB" apps/accommodations/frontend/app/stay/room/*/page.tsx` -- should be 0
7. Shows WifiCard: `grep "WifiCard" apps/accommodations/frontend/app/stay/room/*/page.tsx`
8. No guest name shown: no reference to guestName in rendered output
9. Two render paths: grep for "hasActiveBooking" conditional
10. Build test: `cd apps/accommodations/frontend && npx next build 2>&1 | tail -20` -- should compile without errors
    </verify>
    <done>
    Room dashboard at /stay/room/[roomCode]: two render paths (no-booking property info page, active-booking browse dashboard). Shows WiFi, property info, house rules, contacts, checkout countdown, F&B link. Hides guest name, orders, cart (browse tier privacy). TypeScript compiles. Build passes.
    </done>
    </task>

</tasks>

<verification>
1. Types compile: `cd apps/accommodations/frontend && npx tsc --noEmit` passes
2. Build succeeds: `cd apps/accommodations/frontend && npx next build` passes
3. Existing verify route unchanged: `git diff apps/accommodations/frontend/app/api/stay/verify/route.ts` shows no changes
4. Existing stay/[code] page unchanged: `git diff apps/accommodations/frontend/app/stay/[code]/page.tsx` shows no changes
5. New API route exists: `ls apps/accommodations/frontend/app/api/stay/room/*/route.ts`
6. New hook exists: `ls apps/accommodations/frontend/hooks/useRoomSession.ts`
7. New page exists: `ls apps/accommodations/frontend/app/stay/room/*/page.tsx`
8. Browse-tier JWT: auth.ts supports accessTier claim with 'full' default for backward compat
9. Room code validation: API route rejects codes not matching RM-[A-HJ-NP-Z2-9]{8}
10. Privacy: browse tier does not expose guest name or booking code in API response
</verification>

<success_criteria>

- QRA-01: Guest scans room QR and immediately sees dashboard with WiFi and property info -- zero login forms
- QRA-02: Room code in URL resolves to active booking via resolve_room_access RPC
- QRA-03: No-booking case shows property info page (not error)
- QRA-05: Legacy /stay/[code] route is completely untouched
- AUTH-01: WiFi, property info, contacts, house rules visible without any verification
- Browse-tier JWT with accessTier claim enables Phase 26 progressive auth upgrade
  </success_criteria>

<output>
After completion, create `.planning/phases/25-room-code-foundation/25-02-SUMMARY.md`
</output>
