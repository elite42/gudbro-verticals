# Best Practices per Migrazioni Database

> **Lezioni apprese da errori reali durante lo sviluppo GUDBRO**
>
> Questo file documenta pattern corretti e errori da evitare nelle migrazioni PostgreSQL.

---

## 1. Rinominare Tabelle

### Checklist PRIMA di Rinominare

```
[ ] Identificare TUTTE le dipendenze:
    [ ] product_ingredients (product_type = 'old_name')
    [ ] product_taxonomy (product_type = 'old_name')
    [ ] Altre junction tables
    [ ] Views che referenziano la tabella
    [ ] Functions/Triggers associati
[ ] Verificare CHECK constraints che contengono il vecchio nome
[ ] Preparare script con ordine corretto delle operazioni
[ ] Testare su ambiente di sviluppo prima di produzione
```

### Ordine Corretto delle Operazioni

```sql
BEGIN;

-- 1. PRIMA: Aggiornare CHECK constraints (se necessario)
ALTER TABLE other_table DROP CONSTRAINT IF EXISTS constraint_name;
ALTER TABLE other_table ADD CONSTRAINT constraint_name CHECK (column IN ('old_value', 'new_value', ...));

-- 2. POI: Rinominare la tabella
ALTER TABLE old_name RENAME TO new_name;

-- 3. POI: Aggiornare riferimenti nelle altre tabelle
UPDATE product_ingredients SET product_type = 'new_name' WHERE product_type = 'old_name';
UPDATE product_taxonomy SET product_type = 'new_name' WHERE product_type = 'old_name';

-- 4. INFINE: Rinominare funzioni associate (se esistono)
-- Vedi sezione "Rinominare Functions"

COMMIT;
```

---

## 2. Modificare CHECK Constraints

### Pattern SBAGLIATO ❌

```sql
-- Questo FALLISCE se il valore non è nel CHECK attuale
UPDATE product_taxonomy SET category = 'sushi' WHERE product_type = 'japanese';
-- ERROR: new row violates check constraint "product_taxonomy_category_check"
```

### Pattern CORRETTO ✅

```sql
-- 1. PRIMA: Rimuovere il vecchio constraint
ALTER TABLE product_taxonomy DROP CONSTRAINT IF EXISTS product_taxonomy_category_check;

-- 2. POI: Aggiungere il nuovo constraint con i valori aggiornati
ALTER TABLE product_taxonomy ADD CONSTRAINT product_taxonomy_category_check
CHECK (category IN ('appetizer', 'first_course', 'second_course', 'sushi', ...));

-- 3. INFINE: Aggiornare i dati
UPDATE product_taxonomy SET category = 'sushi' WHERE product_type = 'japanese';
```

---

## 3. Rinominare Functions

### Pattern SBAGLIATO ❌

```sql
-- ERRORE: "IF EXISTS" non è supportato con ALTER FUNCTION in PostgreSQL
ALTER FUNCTION IF EXISTS old_function_name() RENAME TO new_function_name;
-- ERROR: syntax error at or near "EXISTS"
```

### Pattern CORRETTO ✅

```sql
-- Usare DO block per controllare esistenza
DO $$
BEGIN
  IF EXISTS (SELECT 1 FROM pg_proc WHERE proname = 'old_function_name') THEN
    ALTER FUNCTION old_function_name() RENAME TO new_function_name;
  END IF;
END $$;
```

---

## 4. Transazioni e Rollback

### Problema: Esecuzione Parziale

Quando uno script fallisce a metà, alcune operazioni potrebbero essere già state eseguite (se non in transazione).

### Soluzione: Sempre Usare Transazioni

```sql
BEGIN;

-- Tutte le operazioni qui...
-- Se qualcosa fallisce, tutto viene annullato

COMMIT;
```

### Soluzione Avanzata: Script Idempotenti

Scrivere script che possono essere eseguiti più volte senza problemi:

```sql
-- Idempotente: usa IF NOT EXISTS / IF EXISTS
CREATE TABLE IF NOT EXISTS ...;
DROP CONSTRAINT IF EXISTS ...;

-- Idempotente: usa ON CONFLICT
INSERT INTO ... ON CONFLICT DO NOTHING;

-- Idempotente: controlla prima di aggiornare
UPDATE table SET column = 'value' WHERE column != 'value';
```

---

## 5. Verifica Post-Migrazione

### Query di Verifica Standard

```sql
-- Verificare che la nuova tabella esista
SELECT COUNT(*) FROM new_table_name;

-- Verificare che i riferimenti siano aggiornati
SELECT COUNT(*) FROM product_ingredients WHERE product_type = 'new_name';
SELECT COUNT(*) FROM product_ingredients WHERE product_type = 'old_name'; -- Deve essere 0

-- Verificare che la vecchia tabella non esista più
-- Questa query deve fallire con "table does not exist"
SELECT COUNT(*) FROM old_table_name;
```

---

## 6. Errori Comuni PostgreSQL

| Errore | Causa | Soluzione |
|--------|-------|-----------|
| `syntax error at or near "EXISTS"` | `ALTER FUNCTION IF EXISTS` non supportato | Usare `DO $$ BEGIN IF EXISTS... END $$` |
| `violates check constraint` | Valore non permesso dal CHECK | Aggiornare CHECK prima di UPDATE |
| `relation "x" does not exist` | Tabella già rinominata/eliminata | Verificare stato attuale prima di procedere |
| `duplicate key value violates unique constraint` | Record già esistente | Usare `ON CONFLICT DO NOTHING` |
| `cannot drop constraint...does not exist` | Constraint già rimosso | Usare `DROP CONSTRAINT IF EXISTS` |

---

## 7. Template Script di Migrazione

```sql
-- ============================================
-- GUDBRO Migration: [descrizione]
-- Version: 1.0
-- Date: YYYY-MM-DD
-- ============================================
--
-- PURPOSE:
-- [Descrivere cosa fa la migrazione]
--
-- AFFECTS:
-- [Elencare tabelle/oggetti coinvolti]
--
-- PRE-REQUISITES:
-- [Elencare dipendenze o ordine di esecuzione]
--
-- ============================================

BEGIN;

-- ============================================
-- STEP 1: [Descrizione]
-- ============================================

-- SQL qui...

-- ============================================
-- STEP 2: [Descrizione]
-- ============================================

-- SQL qui...

-- ============================================
-- VERIFICATION (run manually after COMMIT)
-- ============================================

-- SELECT COUNT(*) FROM ...;
-- SELECT * FROM ... WHERE ...;

COMMIT;
```

---

## 8. Naming Convention per Script di Migrazione

```
{database}/scripts/
├── {database}-complete-import.sql     # Schema + dati iniziali
├── {database}-missing-ingredients.sql # Ingredienti da aggiungere
├── {database}-product-ingredients.sql # Links junction table
└── migrate-{old}-to-{new}.sql         # Script di migrazione/rename
```

---

**File:** `shared/database/MIGRATION-BEST-PRACTICES.md`
**Created:** 2025-12-18
**Based on:** Errori reali durante migrazione japanese → sushi e creazione product_taxonomy
