---
phase: 15-merchant-notifications
plan: 02
type: execute
wave: 2
depends_on: ['15-01']
files_modified:
  - apps/backoffice/hooks/useNotifications.ts
  - apps/backoffice/components/notifications/NotificationDropdown.tsx
autonomous: true

must_haves:
  truths:
    - 'Bell icon in global header shows unread count badge that updates every 60 seconds'
    - 'Opening the dropdown shows real notifications from fb_merchant_notifications'
    - 'Merchant can mark a single notification as read'
    - 'Merchant can mark all notifications as read'
    - 'Notifications display type-appropriate icons and time-ago formatting'
  artifacts:
    - path: 'apps/backoffice/hooks/useNotifications.ts'
      provides: 'Polling hook for notification data with mark-as-read actions'
      exports: ['useNotifications']
    - path: 'apps/backoffice/components/notifications/NotificationDropdown.tsx'
      provides: 'Bell icon dropdown using real API data instead of mock'
  key_links:
    - from: 'apps/backoffice/hooks/useNotifications.ts'
      to: '/api/feedback/notifications'
      via: 'fetch in useEffect with 60s setInterval'
      pattern: 'fetch.*api/feedback/notifications'
    - from: 'apps/backoffice/components/notifications/NotificationDropdown.tsx'
      to: 'apps/backoffice/hooks/useNotifications.ts'
      via: 'import useNotifications'
      pattern: 'useNotifications'
---

<objective>
Replace mock data in NotificationDropdown with real API calls via a useNotifications hook that polls every 60 seconds.

Purpose: Merchants see actual notifications about their feedback submissions in the bell icon dropdown, with live unread count and mark-as-read functionality.
Output: useNotifications hook with 60s polling, and modified NotificationDropdown component wired to real data.
</objective>

<execution_context>
@/Users/gianfrancodagostino/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gianfrancodagostino/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-merchant-notifications/15-RESEARCH.md
@.planning/phases/15-merchant-notifications/15-01-SUMMARY.md

Key source files to reference:
@apps/backoffice/components/notifications/NotificationDropdown.tsx (existing component with mock data)
@apps/backoffice/components/layout/Header.tsx (where NotificationDropdown is rendered - uses useTenant for merchantId)
@apps/backoffice/app/api/feedback/notifications/route.ts (created in Plan 01)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useNotifications polling hook</name>
  <files>
    apps/backoffice/hooks/useNotifications.ts
  </files>
  <action>
Create the `apps/backoffice/hooks/` directory if it does not exist.

Create `apps/backoffice/hooks/useNotifications.ts` as a client-side hook:

```typescript
'use client';
```

Define a `FeedbackNotification` interface matching the API response shape:

- `id: string`
- `type: 'acknowledged' | 'status_changed' | 'resolved' | 'rejected'`
- `title: string`
- `body: string | null`
- `is_read: boolean`
- `submission_id: string | null`
- `task_id: string | null`
- `created_at: string`

Define `UseNotificationsResult` interface:

- `notifications: FeedbackNotification[]`
- `unreadCount: number`
- `isLoading: boolean`
- `markAsRead: (id: string) => Promise<void>`
- `markAllAsRead: () => Promise<void>`
- `refresh: () => Promise<void>`

Export `useNotifications(merchantId: string | null): UseNotificationsResult`:

1. State: `notifications` (FeedbackNotification[]), `unreadCount` (number), `isLoading` (boolean, default true)
2. `fetchNotifications` callback (memoized with useCallback on merchantId):
   - If no merchantId, return early
   - Fetch GET `/api/feedback/notifications?merchantId=${merchantId}`
   - On success: set notifications and unreadCount from response
   - On error: console.error, do NOT throw
   - Finally: set isLoading to false
3. useEffect: call fetchNotifications on mount, then setInterval every 60000ms, cleanup clearInterval
4. `markAsRead(id)`:
   - Optimistically update local state (set is_read: true, decrement unreadCount)
   - PATCH `/api/feedback/notifications` with `{ notificationId: id }`
   - On error: revert by calling fetchNotifications
5. `markAllAsRead()`:
   - Optimistically update all notifications to read, set unreadCount to 0
   - PATCH `/api/feedback/notifications` with `{ markAllRead: true, merchantId }`
   - On error: revert by calling fetchNotifications
6. `refresh`: alias for fetchNotifications

Return all values.
</action>
<verify>
TypeScript compilation: `cd apps/backoffice && npx tsc --noEmit --pretty 2>&1 | head -30`
File exists: `ls apps/backoffice/hooks/useNotifications.ts`
</verify>
<done>
useNotifications hook is exported, accepts merchantId, polls every 60s, and provides markAsRead + markAllAsRead with optimistic updates.
</done>
</task>

<task type="auto">
  <name>Task 2: Wire NotificationDropdown to real data</name>
  <files>
    apps/backoffice/components/notifications/NotificationDropdown.tsx
  </files>
  <action>
Modify the existing `NotificationDropdown.tsx` to use real data from the `useNotifications` hook instead of mock data. Keep the existing UI structure intact -- only change the data source and type mappings.

**Changes to make:**

1. **Add merchantId prop or context:** The component needs merchantId. The Header already has `useTenant()` which provides `brand` and `location`. Two options:
   - Option A (preferred): Accept `merchantId` as an optional prop. If not provided, the component renders the bell with no badge (graceful fallback).
   - Update the Header to pass merchantId: In `Header.tsx`, the `useTenant()` hook provides tenant context. Check if there's a `merchant_id` or equivalent available. If the tenant context has an ID, pass it as `<NotificationDropdown merchantId={brand?.id || location?.merchant_id} />`. If not directly available, check the existing codebase for how merchant_id is resolved (look at how the feedback submit form gets it).

2. **Import and use the hook:**

   ```typescript
   import { useNotifications } from '@/hooks/useNotifications';
   ```

   Inside the component, call:

   ```typescript
   const {
     notifications: feedbackNotifications,
     unreadCount,
     isLoading,
     markAsRead,
     markAllAsRead,
     refresh,
   } = useNotifications(merchantId || null);
   ```

3. **Remove mock data:** Delete `generateMockNotifications()` and the useEffect that calls it. Remove the `mounted` state (the hook handles loading).

4. **Update notification types:** The DB types are `'acknowledged' | 'status_changed' | 'resolved' | 'rejected'`. The existing UI uses `'ai' | 'operations' | 'feedback' | 'business' | 'system'`. Update the `typeConfig` to map feedback notification types:

   Replace the existing `NotificationType` and `typeConfig` with:

   ```typescript
   export type NotificationType =
     | 'acknowledged'
     | 'status_changed'
     | 'resolved'
     | 'rejected';

   const typeConfig: Record<
     NotificationType,
     { icon: typeof Bell; color: string; bg: string }
   > = {
     acknowledged: {
       icon: CheckCircle,
       color: 'text-green-600',
       bg: 'bg-green-100',
     },
     status_changed: {
       icon: ChevronRight,
       color: 'text-blue-600',
       bg: 'bg-blue-100',
     },
     resolved: {
       icon: CheckCircle,
       color: 'text-emerald-600',
       bg: 'bg-emerald-100',
     },
     rejected: { icon: X, color: 'text-red-600', bg: 'bg-red-100' },
   };
   ```

   Add a fallback for unknown types (use the `feedback` style or a default gray).

5. **Update the Notification interface** to match the API response:

   ```typescript
   export interface Notification {
     id: string;
     type: NotificationType;
     title: string;
     body: string | null;
     is_read: boolean;
     submission_id: string | null;
     task_id: string | null;
     created_at: string;
   }
   ```

6. **Update rendering:**
   - Use `feedbackNotifications` instead of local `notifications` state
   - Use `unreadCount` from the hook instead of computing locally
   - For `markAsRead(id)`: call the hook's markAsRead
   - For `markAllAsRead()`: call the hook's markAllAsRead
   - For `dismissNotification`: remove it (we don't delete notifications, only mark as read) OR keep it as visual-only dismiss (filter from local display)
   - For timestamp: use `new Date(notification.created_at)` with the existing `formatDistanceToNow`
   - For message: use `notification.body || ''`
   - For read state: use `notification.is_read` instead of `notification.read`
   - Remove `priority` styling (DB notifications don't have priority, or default to 'low'/no border)
   - Remove `actionUrl`/`actionLabel` (not in DB schema). The footer link "Vedi tutte le notifiche" can link to `/settings/feedback` or be removed.

7. **Loading state:** When `isLoading` is true and dropdown is open, show a simple loading indicator (e.g., "Caricamento..." text or a spinner).

8. **Keep the existing Italian strings** ("Notifiche", "Segna tutte come lette", etc.) -- the backoffice is Italian-facing.

**Important: Do NOT rewrite the component from scratch.** Keep the existing DOM structure, Tailwind classes, bell icon, dropdown positioning, outside-click handler, unread badge, empty state, and footer. Only swap the data source and update type mappings.
</action>
<verify>
TypeScript compilation: `cd apps/backoffice && npx tsc --noEmit --pretty 2>&1 | head -30`
Grep for hook usage: `grep -n 'useNotifications' apps/backoffice/components/notifications/NotificationDropdown.tsx`
Grep mock data removed: `grep -c 'generateMockNotifications' apps/backoffice/components/notifications/NotificationDropdown.tsx` should return 0
</verify>
<done>
NotificationDropdown uses useNotifications hook for real data. Mock data is removed. Bell icon shows live unread count. Dropdown displays real notifications with correct type icons. Mark-as-read works for single and all. 60-second polling is active.
</done>
</task>

</tasks>

<verification>
- `cd apps/backoffice && npx tsc --noEmit` passes
- `useNotifications` hook exists and is imported by NotificationDropdown
- No mock data remains in NotificationDropdown (`generateMockNotifications` removed)
- NotificationDropdown accepts merchantId and renders bell with unread badge
- Type mapping covers all four DB notification types
- Polling interval is 60000ms (60 seconds)
</verification>

<success_criteria>
The bell icon in the backoffice header shows a live unread count that updates every 60 seconds. Opening the dropdown shows real notifications from the database. Merchants can mark notifications as read individually or all at once. The UI maintains its existing look and feel with feedback-specific type icons.
</success_criteria>

<output>
After completion, create `.planning/phases/15-merchant-notifications/15-02-SUMMARY.md`
</output>
