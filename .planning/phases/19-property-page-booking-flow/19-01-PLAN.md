---
phase: 19-property-page-booking-flow
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/accommodations/frontend/package.json
  - apps/accommodations/frontend/types/property.ts
  - apps/accommodations/frontend/lib/price-utils.ts
  - apps/accommodations/frontend/lib/structured-data.ts
  - apps/accommodations/frontend/lib/property-api.ts
  - apps/accommodations/frontend/lib/booking-api.ts
  - apps/accommodations/frontend/app/api/property/[slug]/route.ts
  - apps/accommodations/frontend/app/api/property/[slug]/availability/route.ts
  - apps/accommodations/frontend/app/api/booking/route.ts
autonomous: true

must_haves:
  truths:
    - 'Guest can view any active property page by visiting /property/[slug] (public, no login required)'
    - 'Calendar shows only truly available dates -- expired inquiry bookings do not block dates'
    - 'Guest receives a booking code and JWT token immediately after submitting a booking'
    - 'Price shown to guest uses correct currency formatting (VND no decimals, USD 2 decimals) with accurate discount math'
    - 'Instant bookings are immediately confirmed; inquiry bookings show pending with expiration deadline'
    - 'Two guests cannot book the same room for overlapping dates, even if they submit simultaneously'
  artifacts:
    - path: 'apps/accommodations/frontend/types/property.ts'
      provides: 'TypeScript types for property page, booking form, and API responses'
    - path: 'apps/accommodations/frontend/lib/price-utils.ts'
      provides: 'calculatePriceBreakdown and formatPrice functions'
    - path: 'apps/accommodations/frontend/lib/structured-data.ts'
      provides: 'buildLodgingBusinessSchema for JSON-LD SEO'
    - path: 'apps/accommodations/frontend/app/api/property/[slug]/route.ts'
      provides: 'Public property data endpoint'
      exports: ['GET']
    - path: 'apps/accommodations/frontend/app/api/property/[slug]/availability/route.ts'
      provides: 'Booked date ranges for calendar'
      exports: ['GET']
    - path: 'apps/accommodations/frontend/app/api/booking/route.ts'
      provides: 'Booking submission with JWT response'
      exports: ['POST']
  key_links:
    - from: 'app/api/booking/route.ts'
      to: 'lib/auth.ts signGuestToken'
      via: 'JWT signing after booking creation'
      pattern: 'signGuestToken'
    - from: 'app/api/booking/route.ts'
      to: 'lib/price-utils.ts calculatePriceBreakdown'
      via: 'Server-authoritative price calculation'
      pattern: 'calculatePriceBreakdown'
    - from: 'app/api/property/[slug]/availability/route.ts'
      to: 'accom_bookings table'
      via: 'Query active bookings excluding expired inquiries'
      pattern: 'expires_at'
---

<objective>
Install new dependencies, create TypeScript types, library utilities (pricing, structured data, API helpers), and three API routes for the property page and booking flow.

Purpose: This is the data layer foundation for Phase 19. The API routes serve the property page (SSR + client), the calendar (availability), and the booking form (submission). All subsequent plans (19-02 components, 19-03 page assembly) depend on these types, utils, and endpoints being correct.
Output: 4 new dependencies installed, types file, 3 lib utilities, 2 API client helpers, and 3 API routes.
</objective>

<execution_context>
@/Users/gianfrancodagostino/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gianfrancodagostino/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/19-property-page-booking-flow/19-RESEARCH.md
@.planning/phases/19-property-page-booking-flow/19-CONTEXT.md

# Existing patterns to follow

@apps/accommodations/frontend/lib/supabase.ts
@apps/accommodations/frontend/lib/auth.ts
@apps/accommodations/frontend/types/stay.ts
@apps/accommodations/frontend/app/api/stay/verify/route.ts

# Schema reference (columns we query)

@shared/database/migrations/schema/077-accommodations-schema.sql
@shared/database/migrations/schema/083-accommodations-v2-foundation.sql

# Package.json to extend

@apps/accommodations/frontend/package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install new dependencies</name>
  <files>apps/accommodations/frontend/package.json</files>
  <action>
Add the following dependencies to `apps/accommodations/frontend/package.json`:

- `"embla-carousel-react": "^8.6.0"` -- swipeable photo gallery
- `"react-day-picker": "^9.13.0"` -- inline date range calendar
- `"react-international-phone": "^4.3.0"` -- phone input with country code
- `"schema-dts": "^1.1.0"` -- TypeScript Schema.org types for JSON-LD
- `"@phosphor-icons/react": "^2.1.7"` -- icons (project standard, not yet in this package)

Add to the **dependencies** section (not devDependencies). Keep existing dependencies unchanged.

Then run `pnpm install` from the workspace root to update the lockfile.
</action>
<verify>

1. `grep '"embla-carousel-react"' apps/accommodations/frontend/package.json` -- present
2. `grep '"react-day-picker"' apps/accommodations/frontend/package.json` -- present
3. `grep '"react-international-phone"' apps/accommodations/frontend/package.json` -- present
4. `grep '"schema-dts"' apps/accommodations/frontend/package.json` -- present
5. `grep '"@phosphor-icons/react"' apps/accommodations/frontend/package.json` -- present
6. `pnpm ls embla-carousel-react --filter @gudbro/accommodations-frontend 2>&1 | head -5` -- resolves
   </verify>
   <done>All 5 new dependencies added to package.json and lockfile updated via pnpm install.</done>
   </task>

<task type="auto">
  <name>Task 2: Create property types</name>
  <files>apps/accommodations/frontend/types/property.ts</files>
  <action>
Create `apps/accommodations/frontend/types/property.ts` with TypeScript types for the property page and booking flow. Follow the same pattern as `types/stay.ts` (ApiResponse wrapper, clear JSDoc comments).

**Types to define:**

```typescript
/**
 * Types for Accommodations Property Page & Booking Flow
 *
 * Used by: /property/[slug] page, /api/property/[slug], /api/booking
 * All prices are INTEGER minor currency units (e.g., 50000 = $500.00 or 500,000 VND)
 */

// --- Property Page Data ---

export interface PropertyPageData {
  id: string;
  name: string;
  slug: string;
  type: string; // 'hotel' | 'apartment' | 'villa' | 'homestay' | 'hostel'
  description: string | null;
  address: string | null;
  city: string | null;
  country_code: string;
  latitude: number | null;
  longitude: number | null;
  images: string[];
  amenities: string[];
  house_rules: Record<string, unknown>; // JSONB from DB
  contact_phone: string | null;
  contact_email: string | null;
  contact_whatsapp: string | null;
  check_in_time: string;
  check_out_time: string;
  host_name: string | null;
  host_photo: string | null;
  host_languages: string[];
  booking_mode: 'instant' | 'inquiry' | 'disabled';
  accepted_payment_methods: string[];
  min_nights: number;
  max_nights: number | null;
  cleaning_fee: number; // INTEGER minor units
  weekly_discount_percent: number;
  monthly_discount_percent: number;
  has_linked_fnb: boolean;
  linked_fnb_slug: string | null;
  rooms: PropertyRoom[];
}

export interface PropertyRoom {
  id: string;
  room_number: string;
  room_type: string;
  capacity: number;
  description: string | null;
  base_price_per_night: number; // INTEGER minor units
  currency: string;
  images: string[]; // JSONB array
  beds: RoomBed[]; // JSONB array
  is_active: boolean;
}

export interface RoomBed {
  type: string; // 'single' | 'double' | 'queen' | 'king' | 'bunk'
  count: number;
}

// --- Availability ---

export interface BookedRange {
  from: string; // YYYY-MM-DD (check_in_date)
  to: string; // YYYY-MM-DD (check_out_date, exclusive in half-open [) convention)
}

export interface AvailabilityResponse {
  bookedRanges: BookedRange[];
}

// --- Price Breakdown ---

export interface PriceBreakdown {
  pricePerNight: number; // INTEGER minor units
  nights: number;
  subtotal: number; // pricePerNight * nights
  cleaningFee: number;
  discountAmount: number;
  discountLabel: string | null; // e.g., "10% weekly discount"
  totalPrice: number;
  currency: string;
}

// --- Booking ---

export interface BookingSubmission {
  propertySlug: string;
  roomId: string;
  firstName: string;
  lastName: string;
  email: string;
  phone: string;
  guestCount: number;
  checkIn: string; // YYYY-MM-DD
  checkOut: string; // YYYY-MM-DD
  specialRequests?: string;
}

export interface BookingResponse {
  bookingCode: string;
  token: string;
  status: 'confirmed' | 'pending';
  expiresAt: string | null;
  priceBreakdown: PriceBreakdown;
  propertyName: string;
  hostPhone: string | null;
  hostWhatsapp: string | null;
}

// --- API Errors ---

export type PropertyApiError =
  | 'property_not_found'
  | 'property_disabled'
  | 'room_not_found'
  | 'room_unavailable'
  | 'dates_unavailable'
  | 'invalid_dates'
  | 'min_nights_not_met'
  | 'max_nights_exceeded'
  | 'max_guests_exceeded'
  | 'validation_error'
  | 'internal_error';
```

Import `ApiResponse` from `@/types/stay` is NOT needed -- define a local `ApiResponse<T>` identical to the one in `stay.ts` to keep property types self-contained:

```typescript
export interface ApiResponse<T> {
  data?: T;
  error?: PropertyApiError | string;
}
```

</action>
<verify>
1. `cat apps/accommodations/frontend/types/property.ts` -- file exists and is not empty
2. `grep "PropertyPageData" apps/accommodations/frontend/types/property.ts` -- main type exists
3. `grep "PriceBreakdown" apps/accommodations/frontend/types/property.ts` -- pricing type exists
4. `grep "BookingSubmission" apps/accommodations/frontend/types/property.ts` -- form type exists
5. `grep "BookingResponse" apps/accommodations/frontend/types/property.ts` -- response type exists
6. `grep "INTEGER minor" apps/accommodations/frontend/types/property.ts` -- price documentation present
</verify>
<done>Property types file created with PropertyPageData, PropertyRoom, PriceBreakdown, BookingSubmission, BookingResponse, AvailabilityResponse, and ApiResponse types. All prices documented as INTEGER minor currency units.</done>
</task>

<task type="auto">
  <name>Task 3: Create price-utils library</name>
  <files>apps/accommodations/frontend/lib/price-utils.ts</files>
  <action>
Create `apps/accommodations/frontend/lib/price-utils.ts` following the exact code from the research document (Pattern 5). This file is used BOTH client-side (preview) and server-side (authoritative).

The file must contain:

1. `calculatePriceBreakdown(pricePerNight, checkIn, checkOut, cleaningFee, weeklyDiscountPercent, monthlyDiscountPercent, currency)` -- returns PriceBreakdown
   - Uses `differenceInDays` from date-fns
   - Monthly discount (>=28 nights) takes priority over weekly (>=7 nights)
   - `Math.round()` for discount amount
   - Import PriceBreakdown from `@/types/property`

2. `formatPrice(amount, currency)` -- returns formatted string
   - VND: no decimals (minor units = 1, so 500000 displays as "500,000 VND")
   - USD and others: 2 decimals (minor units = 100, so 4500 displays as "$45.00")
   - Uses `Intl.NumberFormat`

Copy the EXACT implementation from 19-RESEARCH.md Pattern 5, adjusting the import path for `PriceBreakdown` type.

Add JSDoc comment at the top:

```
/**
 * Price Calculation Utilities for Accommodations Booking
 *
 * All prices are INTEGER minor currency units:
 * - VND: 1 unit = 1 VND (500000 = 500,000 VND)
 * - USD: 1 unit = 1 cent (4500 = $45.00)
 *
 * IMPORTANT: Client-side calculation is for PREVIEW only.
 * Server recalculates authoritatively on booking submission.
 */
```

</action>
<verify>
1. `cat apps/accommodations/frontend/lib/price-utils.ts` -- file exists
2. `grep "calculatePriceBreakdown" apps/accommodations/frontend/lib/price-utils.ts` -- function exists
3. `grep "formatPrice" apps/accommodations/frontend/lib/price-utils.ts` -- function exists
4. `grep "Math.round" apps/accommodations/frontend/lib/price-utils.ts` -- consistent rounding
5. `grep "differenceInDays" apps/accommodations/frontend/lib/price-utils.ts` -- uses date-fns
6. `grep "Intl.NumberFormat" apps/accommodations/frontend/lib/price-utils.ts` -- proper formatting
</verify>
<done>price-utils.ts created with calculatePriceBreakdown (discount logic, Math.round) and formatPrice (Intl.NumberFormat, VND special case). Both import PriceBreakdown from @/types/property.</done>
</task>

<task type="auto">
  <name>Task 4: Create structured-data library for JSON-LD SEO</name>
  <files>apps/accommodations/frontend/lib/structured-data.ts</files>
  <action>
Create `apps/accommodations/frontend/lib/structured-data.ts` with the `buildLodgingBusinessSchema` function from the research document.

Implementation:

```typescript
/**
 * JSON-LD Structured Data for Property Pages
 *
 * Generates Schema.org LodgingBusiness markup for SEO.
 * Used in the server component to render in <script type="application/ld+json">.
 */
import type { WithContext, LodgingBusiness } from 'schema-dts';
import type { PropertyPageData } from '@/types/property';
import { formatPrice } from './price-utils';

export function buildLodgingBusinessSchema(
  property: PropertyPageData
): WithContext<LodgingBusiness> {
  // Calculate price range from rooms
  const priceRange = formatPriceRange(property.rooms);

  return {
    '@context': 'https://schema.org',
    '@type': 'LodgingBusiness',
    name: property.name,
    description: property.description || undefined,
    image: property.images?.[0] || undefined,
    address: {
      '@type': 'PostalAddress',
      streetAddress: property.address || undefined,
      addressLocality: property.city || undefined,
      addressCountry: property.country_code,
    },
    geo:
      property.latitude && property.longitude
        ? {
            '@type': 'GeoCoordinates',
            latitude: property.latitude,
            longitude: property.longitude,
          }
        : undefined,
    telephone: property.contact_phone || undefined,
    checkinTime: property.check_in_time,
    checkoutTime: property.check_out_time,
    amenityFeature: property.amenities?.map((amenity: string) => ({
      '@type': 'LocationFeatureSpecification' as const,
      name: amenity,
      value: true,
    })),
    numberOfRooms: property.rooms?.length,
    priceRange,
  };
}

function formatPriceRange(
  rooms: PropertyPageData['rooms']
): string | undefined {
  if (!rooms || rooms.length === 0) return undefined;

  const activeRooms = rooms.filter((r) => r.is_active);
  if (activeRooms.length === 0) return undefined;

  const prices = activeRooms.map((r) => r.base_price_per_night);
  const currency = activeRooms[0].currency;
  const min = Math.min(...prices);
  const max = Math.max(...prices);

  if (min === max) {
    return formatPrice(min, currency);
  }
  return `${formatPrice(min, currency)} - ${formatPrice(max, currency)}`;
}
```

</action>
<verify>
1. `cat apps/accommodations/frontend/lib/structured-data.ts` -- file exists
2. `grep "buildLodgingBusinessSchema" apps/accommodations/frontend/lib/structured-data.ts` -- function exists
3. `grep "LodgingBusiness" apps/accommodations/frontend/lib/structured-data.ts` -- Schema.org type
4. `grep "schema-dts" apps/accommodations/frontend/lib/structured-data.ts` -- uses schema-dts types
5. `grep "formatPriceRange" apps/accommodations/frontend/lib/structured-data.ts` -- helper exists
</verify>
<done>structured-data.ts created with buildLodgingBusinessSchema returning typed Schema.org LodgingBusiness with property details, geo, amenities, and price range from rooms.</done>
</task>

<task type="auto">
  <name>Task 5: Create API route GET /api/property/[slug]</name>
  <files>apps/accommodations/frontend/app/api/property/[slug]/route.ts</files>
  <action>
Create `apps/accommodations/frontend/app/api/property/[slug]/route.ts` -- the public property data endpoint.

Follow the EXACT pattern from `app/api/stay/verify/route.ts` for imports, error handling, and response shape.

Requirements:

1. `export const dynamic = 'force-dynamic';`
2. Public endpoint -- no JWT auth required
3. Query `accom_properties` by slug with `is_active = true`
4. Join `accom_rooms` where `is_active = true`
5. Return `ApiResponse<PropertyPageData>` shape
6. Return 404 for missing/inactive property
7. Return 403 if `booking_mode = 'disabled'` (property exists but not accepting bookings)

Query should select ALL columns needed by `PropertyPageData` type:

- From accom_properties: id, name, slug, type, description, address, city, country_code, latitude, longitude, images, amenities, house_rules, contact_phone, contact_email, contact_whatsapp, check_in_time, check_out_time, host_name, host_photo, host_languages, booking_mode, accepted_payment_methods, min_nights, max_nights, cleaning_fee, weekly_discount_percent, monthly_discount_percent, has_linked_fnb, linked_fnb_slug
- From accom_rooms (join): id, room_number, room_type, capacity, description, base_price_per_night, currency, images, beds, is_active

Map DB column naming to match the TypeScript types. Since DB columns use snake_case and our types also use snake_case, the mapping is direct -- just ensure the join result structure matches `PropertyPageData`.

Important: Use `getSupabaseAdmin()` from `@/lib/supabase` (same as existing routes). Import types from `@/types/property`.

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { getSupabaseAdmin } from '@/lib/supabase';
import type { ApiResponse, PropertyPageData } from '@/types/property';

export const dynamic = 'force-dynamic';

export async function GET(
  _request: NextRequest,
  { params }: { params: { slug: string } }
) {
  try {
    const supabase = getSupabaseAdmin();

    const { data: property, error } = await supabase
      .from('accom_properties')
      .select(
        `
        id, name, slug, type, description, address, city, country_code,
        latitude, longitude, images, amenities, house_rules,
        contact_phone, contact_email, contact_whatsapp,
        check_in_time, check_out_time,
        host_name, host_photo, host_languages,
        booking_mode, accepted_payment_methods,
        min_nights, max_nights, cleaning_fee,
        weekly_discount_percent, monthly_discount_percent,
        has_linked_fnb, linked_fnb_slug,
        accom_rooms!inner(
          id, room_number, room_type, capacity, description,
          base_price_per_night, currency, images, beds, is_active
        )
      `
      )
      .eq('slug', params.slug)
      .eq('is_active', true)
      .single();

    if (error || !property) {
      return NextResponse.json<ApiResponse<null>>(
        { error: 'property_not_found' },
        { status: 404 }
      );
    }

    // Map rooms from join result
    const rooms = (
      property.accom_rooms as unknown as PropertyPageData['rooms']
    ).filter((r) => r.is_active);

    if (rooms.length === 0) {
      return NextResponse.json<ApiResponse<null>>(
        { error: 'property_not_found' },
        { status: 404 }
      );
    }

    const propertyData: PropertyPageData = {
      ...(property as unknown as Omit<PropertyPageData, 'rooms'>),
      rooms,
    };

    return NextResponse.json<ApiResponse<PropertyPageData>>({
      data: propertyData,
    });
  } catch (err) {
    console.error('GET /api/property/[slug] error:', err);
    return NextResponse.json<ApiResponse<null>>(
      { error: 'internal_error' },
      { status: 500 }
    );
  }
}
```

Adapt this pattern but ensure the type casting is clean. The key is that Supabase returns the join as an array property `accom_rooms` on the result object.
</action>
<verify>

1. `cat apps/accommodations/frontend/app/api/property/[slug]/route.ts` -- file exists
2. `grep "getSupabaseAdmin" apps/accommodations/frontend/app/api/property/[slug]/route.ts` -- uses admin client
3. `grep "force-dynamic" apps/accommodations/frontend/app/api/property/[slug]/route.ts` -- dynamic route
4. `grep "property_not_found" apps/accommodations/frontend/app/api/property/[slug]/route.ts` -- 404 handling
5. `grep "accom_rooms" apps/accommodations/frontend/app/api/property/[slug]/route.ts` -- joins rooms
6. `grep "is_active" apps/accommodations/frontend/app/api/property/[slug]/route.ts` -- filters active only
   </verify>
   <done>Property API route created at /api/property/[slug] with Supabase admin query joining rooms, active-only filtering, 404 handling, and ApiResponse typed response.</done>
   </task>

<task type="auto">
  <name>Task 6: Create API route GET /api/property/[slug]/availability</name>
  <files>apps/accommodations/frontend/app/api/property/[slug]/availability/route.ts</files>
  <action>
Create `apps/accommodations/frontend/app/api/property/[slug]/availability/route.ts` -- returns booked date ranges for the calendar.

Requirements:

1. `export const dynamic = 'force-dynamic';`
2. Public endpoint -- no JWT auth required
3. Accepts query param `room_id` (required)
4. First resolve slug to property_id (query accom_properties by slug)
5. Query `accom_bookings` for the given room_id where:
   - `status NOT IN ('cancelled', 'no_show')`
   - `check_out_date >= today` (only future/current bookings)
   - **Exclude expired inquiries**: `expires_at IS NULL OR expires_at >= NOW()`
6. Select only `check_in_date, check_out_date` (minimal data)
7. Return `ApiResponse<AvailabilityResponse>` with `bookedRanges` array
8. Each range has `from` (check_in) and `to` (check_out) -- the client handles half-open conversion

The query for excluding expired inquiries:

```sql
.or('expires_at.is.null,expires_at.gte.' + new Date().toISOString())
```

Return 400 if room_id is missing. Return 404 if property slug not found.

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { getSupabaseAdmin } from '@/lib/supabase';
import type { ApiResponse, AvailabilityResponse } from '@/types/property';

export const dynamic = 'force-dynamic';

export async function GET(
  request: NextRequest,
  { params }: { params: { slug: string } }
) {
  try {
    const roomId = request.nextUrl.searchParams.get('room_id');
    if (!roomId) {
      return NextResponse.json<ApiResponse<null>>(
        { error: 'validation_error' },
        { status: 400 }
      );
    }

    const supabase = getSupabaseAdmin();

    // Resolve slug to property_id
    const { data: property } = await supabase
      .from('accom_properties')
      .select('id')
      .eq('slug', params.slug)
      .eq('is_active', true)
      .single();

    if (!property) {
      return NextResponse.json<ApiResponse<null>>(
        { error: 'property_not_found' },
        { status: 404 }
      );
    }

    const today = new Date().toISOString().split('T')[0];
    const now = new Date().toISOString();

    const { data: bookings, error } = await supabase
      .from('accom_bookings')
      .select('check_in_date, check_out_date')
      .eq('property_id', property.id)
      .eq('room_id', roomId)
      .not('status', 'in', '("cancelled","no_show")')
      .gte('check_out_date', today)
      .or(`expires_at.is.null,expires_at.gte.${now}`);

    if (error) {
      console.error('Availability query error:', error);
      return NextResponse.json<ApiResponse<null>>(
        { error: 'internal_error' },
        { status: 500 }
      );
    }

    return NextResponse.json<ApiResponse<AvailabilityResponse>>({
      data: {
        bookedRanges: (bookings || []).map((b) => ({
          from: b.check_in_date,
          to: b.check_out_date,
        })),
      },
    });
  } catch (err) {
    console.error('GET /api/property/[slug]/availability error:', err);
    return NextResponse.json<ApiResponse<null>>(
      { error: 'internal_error' },
      { status: 500 }
    );
  }
}
```

</action>
<verify>
1. `cat apps/accommodations/frontend/app/api/property/[slug]/availability/route.ts` -- file exists
2. `grep "expires_at" apps/accommodations/frontend/app/api/property/[slug]/availability/route.ts` -- filters expired inquiries
3. `grep "cancelled.*no_show" apps/accommodations/frontend/app/api/property/[slug]/availability/route.ts` -- excludes cancelled
4. `grep "room_id" apps/accommodations/frontend/app/api/property/[slug]/availability/route.ts` -- accepts room param
5. `grep "bookedRanges" apps/accommodations/frontend/app/api/property/[slug]/availability/route.ts` -- returns ranges
6. `grep "check_in_date.*check_out_date" apps/accommodations/frontend/app/api/property/[slug]/availability/route.ts` -- selects only date columns
</verify>
<done>Availability API route created with room_id filtering, expired inquiry exclusion, cancelled/no_show exclusion, and minimal data selection (dates only).</done>
</task>

<task type="auto">
  <name>Task 7: Create API route POST /api/booking</name>
  <files>apps/accommodations/frontend/app/api/booking/route.ts</files>
  <action>
Create `apps/accommodations/frontend/app/api/booking/route.ts` -- the booking submission endpoint.

This is the most complex API route. Follow the pattern from research (Pattern 3) but with full validation.

Requirements:

1. `export const dynamic = 'force-dynamic';`
2. Parse and validate request body matching `BookingSubmission` type
3. Validate: all required fields present, check-in before check-out, dates in future
4. Look up property by slug (must be active, booking_mode !== 'disabled')
5. Look up room by roomId (must belong to property, must be active)
6. Check min_nights / max_nights constraints
7. Check guest count <= room capacity
8. Calculate price using `calculatePriceBreakdown` from `@/lib/price-utils`
9. Determine booking status: `property.booking_mode === 'instant' ? 'confirmed' : 'pending'`
10. Set `expires_at` for pending bookings: `addHours(new Date(), property.inquiry_timeout_hours)`
11. Insert into `accom_bookings` with all pricing fields
12. The DB `generate_booking_code()` trigger auto-creates the booking code
13. Sign JWT using `signGuestToken` from `@/lib/auth`
14. Return `ApiResponse<BookingResponse>` with bookingCode, token, status, expiresAt, priceBreakdown, propertyName, hostPhone, hostWhatsapp

Error handling:

- 400 for validation errors (missing fields, invalid dates, min/max nights, guest count)
- 404 for property/room not found
- 409 for dates_unavailable (if DB exclusion constraint rejects -- catch unique_violation/exclusion_violation)
- 500 for internal errors

Important: Do NOT check availability in application code before inserting. Let the DB exclusion constraint handle it -- catch the error and return 409. This is race-condition safe.

```typescript
import { NextRequest, NextResponse } from 'next/server';
import {
  differenceInDays,
  parseISO,
  addHours,
  isBefore,
  startOfDay,
} from 'date-fns';
import { getSupabaseAdmin } from '@/lib/supabase';
import { signGuestToken } from '@/lib/auth';
import { calculatePriceBreakdown } from '@/lib/price-utils';
import type {
  ApiResponse,
  BookingResponse,
  BookingSubmission,
} from '@/types/property';

export const dynamic = 'force-dynamic';

export async function POST(request: NextRequest) {
  try {
    let body: BookingSubmission;
    try {
      body = await request.json();
    } catch {
      return NextResponse.json<ApiResponse<null>>(
        { error: 'validation_error' },
        { status: 400 }
      );
    }

    // Validate required fields
    const {
      propertySlug,
      roomId,
      firstName,
      lastName,
      email,
      phone,
      guestCount,
      checkIn,
      checkOut,
    } = body;
    if (
      !propertySlug ||
      !roomId ||
      !firstName ||
      !lastName ||
      !email ||
      !phone ||
      !guestCount ||
      !checkIn ||
      !checkOut
    ) {
      return NextResponse.json<ApiResponse<null>>(
        { error: 'validation_error' },
        { status: 400 }
      );
    }

    // Validate dates
    const checkInDate = parseISO(checkIn);
    const checkOutDate = parseISO(checkOut);
    const today = startOfDay(new Date());

    if (isBefore(checkInDate, today)) {
      return NextResponse.json<ApiResponse<null>>(
        { error: 'invalid_dates' },
        { status: 400 }
      );
    }

    if (!isBefore(checkInDate, checkOutDate)) {
      return NextResponse.json<ApiResponse<null>>(
        { error: 'invalid_dates' },
        { status: 400 }
      );
    }

    const nights = differenceInDays(checkOutDate, checkInDate);

    const supabase = getSupabaseAdmin();

    // Fetch property
    const { data: property, error: propError } = await supabase
      .from('accom_properties')
      .select(
        'id, name, booking_mode, min_nights, max_nights, cleaning_fee, weekly_discount_percent, monthly_discount_percent, inquiry_timeout_hours, contact_phone, contact_whatsapp'
      )
      .eq('slug', propertySlug)
      .eq('is_active', true)
      .single();

    if (propError || !property) {
      return NextResponse.json<ApiResponse<null>>(
        { error: 'property_not_found' },
        { status: 404 }
      );
    }

    if (property.booking_mode === 'disabled') {
      return NextResponse.json<ApiResponse<null>>(
        { error: 'property_disabled' },
        { status: 403 }
      );
    }

    // Validate min/max nights
    if (nights < property.min_nights) {
      return NextResponse.json<ApiResponse<null>>(
        { error: 'min_nights_not_met' },
        { status: 400 }
      );
    }
    if (property.max_nights && nights > property.max_nights) {
      return NextResponse.json<ApiResponse<null>>(
        { error: 'max_nights_exceeded' },
        { status: 400 }
      );
    }

    // Fetch room
    const { data: room, error: roomError } = await supabase
      .from('accom_rooms')
      .select('id, base_price_per_night, currency, capacity')
      .eq('id', roomId)
      .eq('property_id', property.id)
      .eq('is_active', true)
      .single();

    if (roomError || !room) {
      return NextResponse.json<ApiResponse<null>>(
        { error: 'room_not_found' },
        { status: 404 }
      );
    }

    // Validate guest count
    if (guestCount > room.capacity) {
      return NextResponse.json<ApiResponse<null>>(
        { error: 'max_guests_exceeded' },
        { status: 400 }
      );
    }

    // Calculate price (server-authoritative)
    const priceBreakdown = calculatePriceBreakdown(
      room.base_price_per_night,
      checkInDate,
      checkOutDate,
      property.cleaning_fee || 0,
      property.weekly_discount_percent || 0,
      property.monthly_discount_percent || 0,
      room.currency
    );

    // Determine booking status
    const status =
      property.booking_mode === 'instant' ? 'confirmed' : 'pending';
    const expiresAt =
      status === 'pending'
        ? addHours(new Date(), property.inquiry_timeout_hours || 24)
        : null;

    // Insert booking -- let DB exclusion constraint handle double-booking
    const { data: booking, error: insertError } = await supabase
      .from('accom_bookings')
      .insert({
        property_id: property.id,
        room_id: roomId,
        guest_name: firstName,
        guest_last_name: lastName,
        guest_email: email,
        guest_phone: phone,
        guest_count: guestCount,
        check_in_date: checkIn,
        check_out_date: checkOut,
        special_requests: body.specialRequests || null,
        status,
        booking_source: 'direct',
        price_per_night: priceBreakdown.pricePerNight,
        num_nights: priceBreakdown.nights,
        subtotal: priceBreakdown.subtotal,
        cleaning_fee: priceBreakdown.cleaningFee,
        discount_amount: priceBreakdown.discountAmount,
        total_price: priceBreakdown.totalPrice,
        currency: priceBreakdown.currency,
        expires_at: expiresAt?.toISOString() || null,
      })
      .select('id, booking_code')
      .single();

    if (insertError) {
      // Check for exclusion constraint violation (double booking)
      if (insertError.code === '23P01') {
        return NextResponse.json<ApiResponse<null>>(
          { error: 'dates_unavailable' },
          { status: 409 }
        );
      }
      console.error('Booking insert error:', insertError);
      return NextResponse.json<ApiResponse<null>>(
        { error: 'internal_error' },
        { status: 500 }
      );
    }

    // Sign JWT for guest
    const token = await signGuestToken({
      bookingId: booking.id,
      propertyId: property.id,
      checkoutDate: checkOut,
    });

    return NextResponse.json<ApiResponse<BookingResponse>>({
      data: {
        bookingCode: booking.booking_code,
        token,
        status: status as 'confirmed' | 'pending',
        expiresAt: expiresAt?.toISOString() || null,
        priceBreakdown,
        propertyName: property.name,
        hostPhone: property.contact_phone,
        hostWhatsapp: property.contact_whatsapp,
      },
    });
  } catch (err) {
    console.error('POST /api/booking error:', err);
    return NextResponse.json<ApiResponse<null>>(
      { error: 'internal_error' },
      { status: 500 }
    );
  }
}
```

CRITICAL: The PostgreSQL error code `23P01` is the exclusion_violation error code. This is how we detect double bookings from the DB constraint.
</action>
<verify>

1. `cat apps/accommodations/frontend/app/api/booking/route.ts` -- file exists
2. `grep "signGuestToken" apps/accommodations/frontend/app/api/booking/route.ts` -- JWT signing
3. `grep "calculatePriceBreakdown" apps/accommodations/frontend/app/api/booking/route.ts` -- server price calc
4. `grep "23P01" apps/accommodations/frontend/app/api/booking/route.ts` -- exclusion constraint handling
5. `grep "expires_at" apps/accommodations/frontend/app/api/booking/route.ts` -- inquiry expiry
6. `grep "booking_mode.*instant.*confirmed.*pending" apps/accommodations/frontend/app/api/booking/route.ts` -- hybrid mode
7. `grep "min_nights\|max_nights\|capacity" apps/accommodations/frontend/app/api/booking/route.ts` -- validates constraints
8. `cd apps/accommodations/frontend && npx tsc --noEmit 2>&1 | head -30` -- no TypeScript errors in new files
   </verify>
   <done>Booking API route created with full validation (fields, dates, min/max nights, guest count), server-authoritative price calculation, hybrid booking mode (instant/inquiry), DB constraint-based double-booking prevention (23P01 catch), JWT signing, and typed BookingResponse.</done>
   </task>

<task type="auto">
  <name>Task 8: Create client API helper libraries</name>
  <files>apps/accommodations/frontend/lib/property-api.ts, apps/accommodations/frontend/lib/booking-api.ts</files>
  <action>
Create two client-side API helper files that components will use to call the API routes.

**File 1: `apps/accommodations/frontend/lib/property-api.ts`**

```typescript
/**
 * Client-side API helpers for property data and availability.
 * Used by client components to fetch from API routes.
 */
import type {
  ApiResponse,
  PropertyPageData,
  AvailabilityResponse,
} from '@/types/property';

const BASE_URL =
  typeof window !== 'undefined' ? '' : process.env.NEXT_PUBLIC_APP_URL || '';

export async function fetchPropertyBySlug(
  slug: string
): Promise<PropertyPageData | null> {
  const res = await fetch(`${BASE_URL}/api/property/${slug}`, {
    cache: 'no-store',
  });
  if (!res.ok) return null;
  const json: ApiResponse<PropertyPageData> = await res.json();
  return json.data || null;
}

export async function fetchAvailability(
  slug: string,
  roomId: string
): Promise<AvailabilityResponse | null> {
  const res = await fetch(
    `${BASE_URL}/api/property/${slug}/availability?room_id=${roomId}`,
    { cache: 'no-store' }
  );
  if (!res.ok) return null;
  const json: ApiResponse<AvailabilityResponse> = await res.json();
  return json.data || null;
}
```

Note: `fetchPropertyBySlug` is called from the server component (SSR) via internal fetch. The BASE_URL logic handles both server and client contexts.

**File 2: `apps/accommodations/frontend/lib/booking-api.ts`**

```typescript
/**
 * Client-side API helper for booking submission.
 * Used by BookingForm component.
 */
import type {
  ApiResponse,
  BookingResponse,
  BookingSubmission,
} from '@/types/property';

export async function submitBooking(
  booking: BookingSubmission
): Promise<{ data?: BookingResponse; error?: string }> {
  try {
    const res = await fetch('/api/booking', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(booking),
    });

    const json: ApiResponse<BookingResponse> = await res.json();

    if (!res.ok) {
      return { error: json.error || 'booking_failed' };
    }

    return { data: json.data };
  } catch {
    return { error: 'network_error' };
  }
}
```

</action>
<verify>
1. `cat apps/accommodations/frontend/lib/property-api.ts` -- file exists
2. `cat apps/accommodations/frontend/lib/booking-api.ts` -- file exists
3. `grep "fetchPropertyBySlug" apps/accommodations/frontend/lib/property-api.ts` -- function exists
4. `grep "fetchAvailability" apps/accommodations/frontend/lib/property-api.ts` -- function exists
5. `grep "submitBooking" apps/accommodations/frontend/lib/booking-api.ts` -- function exists
6. `grep "BookingSubmission" apps/accommodations/frontend/lib/booking-api.ts` -- typed input
</verify>
<done>Two client API helpers created: property-api.ts (fetchPropertyBySlug, fetchAvailability) and booking-api.ts (submitBooking). Both use typed imports from @/types/property.</done>
</task>

</tasks>

<verification>
1. All 5 dependencies in package.json and installable
2. Types file at types/property.ts with all interfaces
3. price-utils.ts with calculatePriceBreakdown and formatPrice
4. structured-data.ts with buildLodgingBusinessSchema
5. GET /api/property/[slug] returns property with rooms
6. GET /api/property/[slug]/availability returns booked ranges, excludes expired inquiries
7. POST /api/booking creates booking, returns JWT, handles double-booking via DB constraint
8. property-api.ts and booking-api.ts client helpers exist
9. TypeScript compiles without errors: `cd apps/accommodations/frontend && npx tsc --noEmit`
</verification>

<success_criteria>

- PROP-06 (partial): API infrastructure for server-rendered property page
- BOOK-01 (partial): Booking submission API with all required fields
- BOOK-02: Hybrid booking mode logic (instant vs inquiry) in booking API
- BOOK-05: Inquiry booking expiry (expires_at on pending bookings, filtered in availability query)
- BOOK-06: Double booking prevention via DB exclusion constraint (23P01 catch in booking API)
- BOOK-07: Guest checkout (no account) -- JWT-based, same as In-Stay pattern
  </success_criteria>

<output>
After completion, create `.planning/phases/19-property-page-booking-flow/19-01-SUMMARY.md`
</output>
