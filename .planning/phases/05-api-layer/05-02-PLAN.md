---
phase: 05-api-layer
plan: 02
type: execute
wave: 2
depends_on: ['05-01']
files_modified:
  - apps/accommodations/frontend/app/api/stay/[code]/services/route.ts
  - apps/accommodations/frontend/app/api/stay/[code]/deals/route.ts
  - apps/accommodations/frontend/app/api/stay/[code]/property/route.ts
autonomous: true

must_haves:
  truths:
    - 'A verified guest can browse property services organized by category with item names and prices'
    - 'A verified guest can see local partnership deals with discount details and how to redeem them'
    - 'A verified guest can view property contact info, house rules, and checkout time'
    - 'An unauthenticated visitor cannot access any protected stay data'
    - 'The session token determines which property data is returned, not the URL'
  artifacts:
    - path: 'apps/accommodations/frontend/app/api/stay/[code]/services/route.ts'
      provides: 'Services endpoint with nested categories and items'
      exports: ['GET']
    - path: 'apps/accommodations/frontend/app/api/stay/[code]/deals/route.ts'
      provides: 'Local partnership deals endpoint'
      exports: ['GET']
    - path: 'apps/accommodations/frontend/app/api/stay/[code]/property/route.ts'
      provides: 'Property info endpoint'
      exports: ['GET']
  key_links:
    - from: 'app/api/stay/[code]/services/route.ts'
      to: 'lib/auth.ts'
      via: 'verifyGuestToken from Authorization header'
      pattern: 'verifyGuestToken'
    - from: 'app/api/stay/[code]/services/route.ts'
      to: 'accom_service_categories + accom_service_items'
      via: 'Supabase joined query'
      pattern: 'accom_service_categories'
    - from: 'app/api/stay/[code]/deals/route.ts'
      to: 'partner_conventions + merchants'
      via: 'Supabase query filtering by partner_id = propertyId'
      pattern: 'partner_conventions'
    - from: 'app/api/stay/[code]/property/route.ts'
      to: 'accom_properties'
      via: 'Supabase query by propertyId from JWT'
      pattern: 'accom_properties'
---

<objective>
Create the three protected API routes that serve stay data behind JWT authentication: services with categories and items, local partnership deals, and property information.

Purpose: These routes complete the API layer, giving the frontend all data endpoints needed for the In-Stay Dashboard (Phase 6). All three require the JWT token from Plan 05-01's verify route.

Output: Three GET routes that return services, deals, and property info. All protected by JWT verification. All using propertyId from the token payload (not derived from URL).
</objective>

<execution_context>
@/Users/gianfrancodagostino/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gianfrancodagostino/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-api-layer/05-CONTEXT.md
@.planning/phases/05-api-layer/05-RESEARCH.md
@.planning/phases/05-api-layer/05-01-SUMMARY.md
@apps/accommodations/frontend/lib/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Services and deals routes</name>
  <files>
    apps/accommodations/frontend/app/api/stay/[code]/services/route.ts
    apps/accommodations/frontend/app/api/stay/[code]/deals/route.ts
  </files>
  <action>
Both routes follow the same auth guard pattern. Create a shared helper at the top of each file (or inline — Claude's discretion) that:
1. Extracts Bearer token from `request.headers.get('authorization')`
2. Calls `verifyGuestToken(token)` from `lib/auth.ts`
3. Returns the guest payload `{ bookingId, propertyId }` or null
4. If null or throws: return 401 `{ error: 'session_expired' }`

**Services route** (`app/api/stay/[code]/services/route.ts`):

- GET handler, requires JWT
- Extract propertyId from verified JWT payload (NOT from URL code — security: use the token's propertyId)
- Query Supabase:
  ```
  supabase.from('accom_service_categories')
    .select(`
      id, name, icon, description, sort_order,
      accom_service_items(
        id, name, description, price, currency, price_type, image, in_stock, sort_order
      )
    `)
    .eq('property_id', propertyId)
    .eq('is_active', true)
    .order('sort_order')
  ```
- Filter out inactive items from the nested results (is_active = false)
- Order nested items by sort_order
- Map DB snake_case to camelCase TypeScript types (ServiceCategoryWithItems, ServiceItemResponse)
- Return price as the raw integer from DB. The types/stay.ts defines price as number. Frontend will handle formatting using the currency code.
- Return 200 `{ data: { categories: [...] } }` matching ServiceCategoryResponse type
- If no categories found, return 200 with empty array (not 404)
- Wrap in try/catch, return 500 on errors

**Deals route** (`app/api/stay/[code]/deals/route.ts`):

- GET handler, requires JWT
- Extract propertyId from verified JWT payload
- The `partner_conventions` table (migration 050) uses a polymorphic partner reference. The seed data (migration 078) stores deals with:
  - `merchant_id` = the local business offering the deal (restaurant, tour operator, etc.)
  - `partner_type` = 'accommodation'
  - `partner_id` = the property UUID directly (e.g., 'a1b2c3d4-e5f6-7890-abcd-ef1234567890')
  - `partner_name` = the property display name
- Query Supabase:
  ```
  supabase.from('partner_conventions')
    .select(`
      id, convention_name, benefit_type, benefit_value, benefit_description,
      valid_from, valid_until, verification_method,
      merchants!partner_conventions_merchant_id_fkey(name, slug, city, logo_url)
    `)
    .eq('partner_id', propertyId)
    .eq('partner_type', 'accommodation')
    .eq('is_active', true)
  ```
- Map results to DealResponse[]:
  - `id` from convention id
  - `merchantName` from joined merchants.name
  - `merchantSlug` from joined merchants.slug
  - `discountLabel` from convention_name (e.g., "10% Guest Discount")
  - `description` from benefit_description
  - `validUntil` from valid_until (nullable)
  - `bookingAction` from verification_method (the frontend will interpret this)
- Return 200 `{ data: deals }` — flat array
- If no deals found, return 200 with empty array
- Wrap in try/catch, return 500 on errors
  </action>
  <verify>
  Run `cd apps/accommodations/frontend && npx tsc --noEmit` — zero type errors.
  </verify>
  <done>
  GET /api/stay/[code]/services returns categories with nested items from accom_service_categories/items. GET /api/stay/[code]/deals returns partner deals by querying partner_conventions where partner_id = propertyId and partner_type = 'accommodation', joined with merchants for display names. Both require valid JWT and use propertyId from token. Both compile without errors.
  </done>
  </task>

<task type="auto">
  <name>Task 2: Property info route and build verification</name>
  <files>
    apps/accommodations/frontend/app/api/stay/[code]/property/route.ts
  </files>
  <action>
**Property route** (`app/api/stay/[code]/property/route.ts`):
- GET handler, requires JWT (same auth guard pattern as Task 1)
- Extract propertyId from verified JWT payload
- Query Supabase:
  ```
  supabase.from('accom_properties')
    .select(`
      id, name, slug, type, description, address, city, area, country,
      contact_phone, contact_whatsapp, contact_email,
      check_in_time, checkout_time, house_rules, amenities,
      images, cover_image, rating, review_count,
      wifi_network, wifi_password
    `)
    .eq('id', propertyId)
    .single()
  ```
- Map to PropertyInfo type (camelCase). house_rules and amenities are Postgres TEXT arrays (string[]).
- Include WiFi info in the response (WifiInfo nested object)
- Return 200 `{ data: { property, wifi } }`
- If not found (shouldn't happen with valid JWT): return 404 `{ error: 'booking_not_found' }`
- Wrap in try/catch, return 500 on errors

**Build verification:**

- Run `pnpm build --filter @gudbro/accommodations-frontend` to confirm all 5 API routes compile in the Next.js production build
- Fix any type errors that emerge from the build
  </action>
  <verify>
  Run `cd apps/accommodations/frontend && npx tsc --noEmit` — zero errors. Run `pnpm build --filter @gudbro/accommodations-frontend` — build succeeds. Verify all 5 route files exist under app/api/stay/.
  </verify>
  <done>
  GET /api/stay/[code]/property returns property info with contact, house rules, checkout time, and WiFi. Full build passes. All 5 API routes (lookup, verify, services, deals, property) compile and build successfully.
  </done>
  </task>

</tasks>

<verification>
1. `cd apps/accommodations/frontend && npx tsc --noEmit` passes with zero errors
2. `pnpm build --filter @gudbro/accommodations-frontend` succeeds
3. All route files exist:
   - app/api/stay/[code]/route.ts (from 05-01)
   - app/api/stay/verify/route.ts (from 05-01)
   - app/api/stay/[code]/services/route.ts
   - app/api/stay/[code]/deals/route.ts
   - app/api/stay/[code]/property/route.ts
4. All protected routes verify JWT and use propertyId from token payload
5. All responses use { data, error } wrapper format
</verification>

<success_criteria>

- Services route returns nested categories with items, filtered by active status
- Deals route returns partner deals from conventions system linked to property
- Property route returns complete property info including WiFi
- All three routes reject requests without valid JWT (401)
- All three routes use propertyId from JWT, not from URL
- Full Next.js build passes with all 5 API routes
  </success_criteria>

<output>
After completion, create `.planning/phases/05-api-layer/05-02-SUMMARY.md`
</output>
