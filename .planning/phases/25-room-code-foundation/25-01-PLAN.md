---
phase: 25-room-code-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - shared/database/migrations/schema/088-room-codes.sql
autonomous: true

must_haves:
  truths:
    - 'Every room in accom_rooms has a unique room_code column in format RM-XXXXXXXX (8 chars, no ambiguous 0/O/1/I/L)'
    - 'generate_room_code() SECURITY DEFINER function generates unique codes with retry loop (follows generate_booking_code() pattern from migration 077)'
    - 'set_room_code() trigger auto-assigns room_code on INSERT when NULL'
    - 'resolve_room_access(p_room_code TEXT) SECURITY DEFINER function maps room code to active booking with date-based resolution'
    - 'resolve_room_access returns is_valid=true, has_active_booking=true with full booking+room data when active booking exists'
    - 'resolve_room_access returns is_valid=true, has_active_booking=false with room+property data when no active booking (fallback)'
    - 'resolve_room_access returns is_valid=false when room code does not exist'
    - 'Date resolution uses timezone-aware comparison: (NOW() AT TIME ZONE prop.timezone)::DATE instead of CURRENT_DATE'
    - 'Booking resolution checks check_in_date <= local_today AND check_out_date + 24h >= NOW() AND status IN (confirmed, checked_in)'
    - 'All existing rooms are backfilled with generated room codes via UPDATE statement'
    - 'idx_accom_rooms_room_code index exists for fast lookup'
    - 'Grant EXECUTE on both functions to anon and authenticated roles'
  artifacts:
    - path: 'shared/database/migrations/schema/088-room-codes.sql'
      provides: 'Room code column, generation function, trigger, resolve_room_access function, backfill'
      contains: 'generate_room_code'
  key_links:
    - from: 'resolve_room_access'
      to: 'accom_rooms'
      via: 'room_code column lookup'
      pattern: 'WHERE r.room_code = p_room_code'
    - from: 'resolve_room_access'
      to: 'accom_bookings'
      via: 'room_id + date-based active booking resolution'
      pattern: 'WHERE b.room_id = v_room_id AND b.check_in_date'
    - from: 'resolve_room_access'
      to: 'accom_properties'
      via: 'property_id for timezone lookup'
      pattern: 'JOIN accom_properties p ON p.id = r.property_id'
---

<objective>
Create migration 088 that adds permanent room codes to accom_rooms and the resolve_room_access() SECURITY DEFINER function for QR-based room access.

Purpose: This is the database foundation for frictionless guest access. Every room gets a permanent code (RM-XXXXXXXX) that resolves to the current active booking via a single RPC call. No booking codes in QR codes anymore -- the QR contains the room code and the system resolves the rest.

Output: Single migration file `088-room-codes.sql` with generate_room_code(), set_room_code() trigger, room_code column + backfill, resolve_room_access() function, index, and grants.
</objective>

<execution_context>
@/Users/gianfrancodagostino/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gianfrancodagostino/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/25-room-code-foundation/25-RESEARCH.md

# Existing schema (the tables we're extending)

@shared/database/migrations/schema/077-accommodations-schema.sql

# Pattern reference: generate_booking_code() and verify_booking_access()

The generate_booking_code() function in migration 077 uses:

- chars TEXT := 'ABCDEFGHJKMNPQRSTUVWXYZ23456789' (excludes 0/O/1/I/L)
- Prefix 'BK-' + 6 random chars
- Loop with EXISTS check for uniqueness
- SECURITY DEFINER SET search_path = public

The verify_booking_access() function in migration 077 uses:

- RETURNS TABLE with is_valid, property_id, booking_id, etc.
- Checks check_in_date <= CURRENT_DATE AND check_out_date + INTERVAL '24 hours' >= NOW()
- Status IN ('confirmed', 'checked_in')

# Schema extensions (columns added later)

@shared/database/migrations/schema/081-schema-api-alignment.sql
@shared/database/migrations/schema/083-accommodations-v2-foundation.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create migration 088 - Room codes and resolve_room_access</name>
  <files>shared/database/migrations/schema/088-room-codes.sql</files>
  <action>
Create `shared/database/migrations/schema/088-room-codes.sql` with ALL sections in this order:

**Header comment:**

```sql
-- ============================================================================
-- Migration 088: Room Codes for QR Access
-- ============================================================================
-- Date: 2026-02-01
-- Description: Adds permanent room codes (RM-XXXXXXXX) to accom_rooms for
--              QR-based guest access. Includes code generation function,
--              auto-set trigger, resolve_room_access() SECURITY DEFINER
--              function for mapping room codes to active bookings.
-- Depends on: 077 (base schema), 081 (timezone column on properties)
-- Part of: v1.5 Frictionless Guest Access (Phase 25)
-- ============================================================================
```

**Section 1: generate_room_code() function**

```sql
CREATE OR REPLACE FUNCTION generate_room_code()
RETURNS TEXT
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
    chars TEXT := 'ABCDEFGHJKMNPQRSTUVWXYZ23456789';
    code TEXT;
    i INTEGER;
    exists_already BOOLEAN;
BEGIN
    LOOP
        code := 'RM-';
        FOR i IN 1..8 LOOP
            code := code || substr(chars, floor(random() * length(chars) + 1)::INTEGER, 1);
        END LOOP;

        SELECT EXISTS(
            SELECT 1 FROM accom_rooms WHERE room_code = code
        ) INTO exists_already;

        IF NOT exists_already THEN
            RETURN code;
        END IF;
    END LOOP;
END;
$$;
```

Exactly follows generate_booking_code() pattern but with 'RM-' prefix and 8 chars instead of 6.

**Section 2: Add room_code column to accom_rooms**

```sql
ALTER TABLE accom_rooms
  ADD COLUMN IF NOT EXISTS room_code TEXT UNIQUE;
```

Add column as nullable first (for backfill), then make NOT NULL after backfill.

**Section 3: set_room_code() trigger function**

```sql
CREATE OR REPLACE FUNCTION set_room_code()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
    IF NEW.room_code IS NULL THEN
        NEW.room_code := generate_room_code();
    END IF;
    RETURN NEW;
END;
$$;
```

Follows exact pattern of set_booking_code() from migration 077.

**Section 4: Create trigger on accom_rooms**

```sql
DROP TRIGGER IF EXISTS set_accom_rooms_room_code ON accom_rooms;
CREATE TRIGGER set_accom_rooms_room_code
    BEFORE INSERT ON accom_rooms
    FOR EACH ROW EXECUTE FUNCTION set_room_code();
```

**Section 5: Backfill existing rooms**

```sql
UPDATE accom_rooms SET room_code = generate_room_code() WHERE room_code IS NULL;
```

Then make the column NOT NULL:

```sql
ALTER TABLE accom_rooms ALTER COLUMN room_code SET NOT NULL;
```

**Section 6: Index for fast room code lookup**

```sql
CREATE INDEX IF NOT EXISTS idx_accom_rooms_room_code ON accom_rooms(room_code);
```

Note: The UNIQUE constraint already creates an implicit unique index, but we add an explicit named one for clarity and documentation.

**Section 7: resolve_room_access() SECURITY DEFINER function**

This is the core function. It:

1. Validates the room code exists and room is active
2. Looks up the property timezone for date resolution
3. Finds the active booking for that room using timezone-aware date comparison
4. Returns full data if booking found, room+property-only data if no booking, invalid if bad code

```sql
CREATE OR REPLACE FUNCTION resolve_room_access(p_room_code TEXT)
RETURNS TABLE(
    is_valid BOOLEAN,
    has_active_booking BOOLEAN,
    property_id UUID,
    room_id UUID,
    booking_id UUID,
    room_number TEXT,
    room_type TEXT,
    guest_name TEXT,
    check_in DATE,
    check_out DATE
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
    v_room_id UUID;
    v_property_id UUID;
    v_room_number TEXT;
    v_room_type TEXT;
    v_timezone TEXT;
    v_local_today DATE;
BEGIN
    -- Step 1: Find the room by code
    SELECT r.id, r.property_id, r.room_number, r.room_type
    INTO v_room_id, v_property_id, v_room_number, v_room_type
    FROM accom_rooms r
    WHERE r.room_code = p_room_code
      AND r.is_active = true;

    -- Invalid room code or inactive room
    IF v_room_id IS NULL THEN
        RETURN QUERY SELECT
            false, false, NULL::UUID, NULL::UUID, NULL::UUID,
            NULL::TEXT, NULL::TEXT, NULL::TEXT, NULL::DATE, NULL::DATE;
        RETURN;
    END IF;

    -- Step 2: Get property timezone for date resolution
    SELECT COALESCE(p.timezone, 'Asia/Ho_Chi_Minh')
    INTO v_timezone
    FROM accom_properties p
    WHERE p.id = v_property_id;

    v_local_today := (NOW() AT TIME ZONE v_timezone)::DATE;

    -- Step 3: Find active booking for this room (timezone-aware)
    RETURN QUERY
    SELECT
        true,
        true,
        v_property_id,
        v_room_id,
        b.id,
        v_room_number,
        v_room_type,
        b.guest_name,
        b.check_in_date,
        b.check_out_date
    FROM accom_bookings b
    WHERE b.room_id = v_room_id
      AND b.check_in_date <= v_local_today
      AND b.check_out_date + INTERVAL '24 hours' >= NOW()
      AND b.status IN ('confirmed', 'checked_in')
    ORDER BY b.check_in_date DESC
    LIMIT 1;

    -- Step 4: No active booking -> return room/property info only
    IF NOT FOUND THEN
        RETURN QUERY SELECT
            true,        -- room code is valid
            false,       -- but no active booking
            v_property_id,
            v_room_id,
            NULL::UUID,  -- no booking
            v_room_number,
            v_room_type,
            NULL::TEXT,  -- no guest name
            NULL::DATE,
            NULL::DATE;
    END IF;
END;
$$;
```

Critical details:

- Uses `(NOW() AT TIME ZONE property.timezone)::DATE` NOT `CURRENT_DATE` (avoids timezone mismatch near midnight)
- Falls back to `'Asia/Ho_Chi_Minh'` if property timezone is NULL (all current properties are in Vietnam)
- ORDER BY check_in_date DESC LIMIT 1 as safety net against impossible overlaps
- Does NOT return guest_last_name (browse tier privacy -- no PII exposed via QR scan)
- Follows verify_booking_access() return shape for consistency

**Section 8: Grants**

```sql
GRANT EXECUTE ON FUNCTION generate_room_code() TO anon;
GRANT EXECUTE ON FUNCTION generate_room_code() TO authenticated;
GRANT EXECUTE ON FUNCTION resolve_room_access(TEXT) TO anon;
GRANT EXECUTE ON FUNCTION resolve_room_access(TEXT) TO authenticated;
```

Anon needs EXECUTE on resolve_room_access because guests call it via the room QR (unauthenticated).

**Section 9: Comments**

```sql
COMMENT ON COLUMN accom_rooms.room_code IS 'Permanent room identifier for QR codes. Format: RM-XXXXXXXX. Never changes between bookings.';
COMMENT ON FUNCTION generate_room_code() IS 'Generates a unique RM-XXXXXXXX room code, excluding ambiguous characters (0/O/1/I/L).';
COMMENT ON FUNCTION resolve_room_access(TEXT) IS 'Maps a room code to the active booking. Returns property+room info even without active booking (fallback for vacant rooms).';
```

  </action>
  <verify>
Verify the SQL file:

1. File exists: `ls shared/database/migrations/schema/088-room-codes.sql`
2. All sections present: `grep -c "generate_room_code\|ALTER TABLE accom_rooms\|set_room_code\|CREATE TRIGGER\|UPDATE accom_rooms\|SET NOT NULL\|idx_accom_rooms_room_code\|resolve_room_access\|GRANT EXECUTE" shared/database/migrations/schema/088-room-codes.sql` -- should be >= 9
3. Room code format: `grep "RM-" shared/database/migrations/schema/088-room-codes.sql` -- prefix present
4. 8-char length: `grep "1\.\.8" shared/database/migrations/schema/088-room-codes.sql` -- 8 char loop
5. Timezone-aware date: `grep "AT TIME ZONE" shared/database/migrations/schema/088-room-codes.sql` -- NOT using CURRENT_DATE
6. No CURRENT_DATE in resolve function: ensure resolve_room_access does NOT use CURRENT_DATE directly
7. Safety net ordering: `grep "ORDER BY b.check_in_date DESC" shared/database/migrations/schema/088-room-codes.sql`
8. SECURITY DEFINER on both functions: `grep -c "SECURITY DEFINER" shared/database/migrations/schema/088-room-codes.sql` -- should be >= 4 (generate_room_code, set_room_code, set_booking_code-style, resolve_room_access)
9. Backfill runs before NOT NULL: verify UPDATE comes before ALTER COLUMN SET NOT NULL
10. Apply migration to Supabase: `mcp__supabase__apply_migration` with name `088_room_codes` and the SQL content
    </verify>
    <done>
    Migration 088 applied: room_code column on accom_rooms (TEXT, UNIQUE, NOT NULL), generate_room_code() function (RM-XXXXXXXX, 8 chars, no ambiguous chars), set_room_code() trigger on INSERT, backfill of all existing rooms, resolve_room_access() SECURITY DEFINER with timezone-aware date resolution and no-booking fallback, index, grants to anon+authenticated.
    </done>
    </task>

</tasks>

<verification>
1. Migration file exists at `shared/database/migrations/schema/088-room-codes.sql`
2. File has header comment with date, description, dependencies
3. generate_room_code() uses RM- prefix + 8 chars from charset excluding 0/O/1/I/L
4. set_room_code() trigger auto-sets room_code on INSERT
5. Backfill UPDATE runs before ALTER COLUMN SET NOT NULL
6. resolve_room_access() uses timezone-aware date comparison (NOT CURRENT_DATE)
7. resolve_room_access() returns 3 distinct result shapes: invalid, valid+booking, valid+no-booking
8. ORDER BY check_in_date DESC LIMIT 1 safety net present
9. GRANT EXECUTE to both anon and authenticated
10. No ENUM types (all TEXT + CHECK where needed)
11. Migration applied successfully to Supabase
</verification>

<success_criteria>

- QRA-02 (partial): Room codes exist on all rooms in RM-XXXXXXXX format, resolve_room_access maps them to active bookings
- QRA-03 (partial): resolve_room_access returns valid=true, has_active_booking=false with room+property data for vacant rooms
- AUTH-01 (partial): resolve_room_access is callable by anon role (no login required)
- Database ready for Plan 25-02 (API route + frontend will consume resolve_room_access via supabase.rpc())
  </success_criteria>

<output>
After completion, create `.planning/phases/25-room-code-foundation/25-01-SUMMARY.md`
</output>
