---
phase: 05-api-layer
plan: 02
type: execute
wave: 2
depends_on: ['05-01']
files_modified:
  - apps/accommodations/frontend/app/api/stay/[code]/services/route.ts
  - apps/accommodations/frontend/app/api/stay/[code]/deals/route.ts
  - apps/accommodations/frontend/app/api/stay/[code]/property/route.ts
autonomous: true

must_haves:
  truths:
    - 'GET /api/stay/[code]/services with valid JWT returns categories with nested items and prices'
    - 'GET /api/stay/[code]/deals with valid JWT returns partner deals from conventions system'
    - 'GET /api/stay/[code]/property with valid JWT returns contact info, house rules, checkout time'
    - 'All three routes return 401 when no Authorization header or invalid/expired JWT'
    - 'All three routes use propertyId from JWT payload, not derived from URL code'
  artifacts:
    - path: 'apps/accommodations/frontend/app/api/stay/[code]/services/route.ts'
      provides: 'Services endpoint with nested categories and items'
      exports: ['GET']
    - path: 'apps/accommodations/frontend/app/api/stay/[code]/deals/route.ts'
      provides: 'Local partnership deals endpoint'
      exports: ['GET']
    - path: 'apps/accommodations/frontend/app/api/stay/[code]/property/route.ts'
      provides: 'Property info endpoint'
      exports: ['GET']
  key_links:
    - from: 'app/api/stay/[code]/services/route.ts'
      to: 'lib/auth.ts'
      via: 'verifyGuestToken from Authorization header'
      pattern: 'verifyGuestToken'
    - from: 'app/api/stay/[code]/services/route.ts'
      to: 'accom_service_categories + accom_service_items'
      via: 'Supabase joined query'
      pattern: 'accom_service_categories'
    - from: 'app/api/stay/[code]/deals/route.ts'
      to: 'partner_conventions + merchants'
      via: 'Supabase joined query on conventions system'
      pattern: 'partner_conventions'
    - from: 'app/api/stay/[code]/property/route.ts'
      to: 'accom_properties'
      via: 'Supabase query by propertyId from JWT'
      pattern: 'accom_properties'
---

<objective>
Create the three protected API routes that serve stay data behind JWT authentication: services with categories and items, local partnership deals, and property information.

Purpose: These routes complete the API layer, giving the frontend all data endpoints needed for the In-Stay Dashboard (Phase 6). All three require the JWT token from Plan 05-01's verify route.

Output: Three GET routes that return services, deals, and property info. All protected by JWT verification. All using propertyId from the token payload (not derived from URL).
</objective>

<execution_context>
@/Users/gianfrancodagostino/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gianfrancodagostino/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-api-layer/05-CONTEXT.md
@.planning/phases/05-api-layer/05-RESEARCH.md
@.planning/phases/05-api-layer/05-01-SUMMARY.md
@apps/accommodations/frontend/lib/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Services and deals routes</name>
  <files>
    apps/accommodations/frontend/app/api/stay/[code]/services/route.ts
    apps/accommodations/frontend/app/api/stay/[code]/deals/route.ts
  </files>
  <action>
Both routes follow the same auth guard pattern. Create a shared helper at the top of each file (or inline — Claude's discretion) that:
1. Extracts Bearer token from `request.headers.get('authorization')`
2. Calls `verifyGuestToken(token)` from `lib/auth.ts`
3. Returns the guest payload `{ bookingId, propertyId }` or null
4. If null or throws: return 401 `{ error: 'session_expired' }`

**Services route** (`app/api/stay/[code]/services/route.ts`):

- GET handler, requires JWT
- Extract propertyId from verified JWT payload (NOT from URL code — security: use the token's propertyId)
- Query Supabase:
  ```
  supabase.from('accom_service_categories')
    .select(`
      id, name, icon, description, sort_order,
      accom_service_items(
        id, name, description, price, currency, price_type, image, in_stock, sort_order
      )
    `)
    .eq('property_id', propertyId)
    .eq('is_active', true)
    .order('sort_order')
  ```
- Filter out inactive items from the nested results (is_active = false)
- Order nested items by sort_order
- Map DB snake_case to camelCase TypeScript types (ServiceCategoryWithItems, ServiceItemResponse)
- Price is stored as INTEGER (minor currency units). Convert to display: `price / 100` for currencies with 2 decimals. For VND (0 decimals), use as-is. Use the currency field to determine. Simplest approach: always return the raw integer and let frontend format — document this in the response type.
- Actually, keep it simple: return price as the raw integer from DB. The types/stay.ts already defines price as number. Frontend will handle formatting using the currency code. This avoids assumptions about currency decimals in the API.
- Return 200 `{ data: { categories: [...] } }` matching ServiceCategoryResponse type
- If no categories found, return 200 with empty array (not 404)
- Wrap in try/catch, return 500 on errors

**Deals route** (`app/api/stay/[code]/deals/route.ts`):

- GET handler, requires JWT
- Extract propertyId from verified JWT payload
- Query the existing conventions system (migration 050). Deals are stored as partner_conventions where the property's merchant is the convention partner:
  ```
  supabase.from('partner_conventions')
    .select(`
      id, discount_label, discount_value, description, valid_from, valid_until,
      booking_action, booking_url, booking_phone,
      merchants!partner_conventions_merchant_id_fkey(name, slug, city, logo_url)
    `)
    .eq('partner_id', propertyId)
    .eq('is_active', true)
    .eq('partner_type', 'accommodation')
  ```
- NOTE: The seed data (04-02) links conventions via partner_id = property UUID and partner_type = 'accommodation'. Verify this matches the actual schema. If the conventions schema uses merchant_id instead, adjust the query accordingly. Check the migration 050 schema.
- Actually, from the seed data (078-accommodations-seed.sql), the convention inserts use: merchant_id (the partner merchant), partner_id (the property's merchant), partner_type 'accommodation'. So the query should filter: `partner_id` = the merchant that owns the property, NOT the property UUID directly. The API needs to first find the property's merchant, then query conventions.
- Revised approach:
  1. Query `accom_properties` to get `owner_id` (the merchant/account that owns the property) for the given propertyId
  2. Actually, review the seed: partner_id in partner_conventions is set to the property's merchant UUID (ff000...001 etc). But the property's owner_id is an account UUID, not a merchant UUID. Need to check if the conventions link to merchant_id or account_id.
  3. SIMPLEST approach: Query conventions where `partner_type = 'accommodation'` and join to find the right ones. Since seed data hard-codes the relationships, query: `partner_conventions.partner_id` matches one of the merchants that represents the property.
  4. FOR NOW: The seed data has merchant_id = the deal provider (restaurant, spa, etc.) and partner_id = a merchant that represents the accommodation. The accommodation property needs a linked merchant. Check seed for the exact linkage pattern and follow it.
  5. Bottom line: Read the seed migration (078) to understand the exact FK relationships before writing the query. The executor should read `shared/database/migrations/schema/078-accommodations-seed.sql` and `shared/database/migrations/schema/050-*.sql` (or whichever file defines partner_conventions) to get the exact column names and relationships.
- Map results to DealResponse[] (camelCase)
- Return 200 `{ data: deals }` — flat array
- If no deals found, return 200 with empty array
- Wrap in try/catch, return 500 on errors
  </action>
  <verify>
  Run `cd apps/accommodations/frontend && npx tsc --noEmit` — zero type errors.
  </verify>
  <done>
  GET /api/stay/[code]/services returns categories with nested items from accom_service_categories/items. GET /api/stay/[code]/deals returns partner deals from conventions system. Both require valid JWT and use propertyId from token. Both compile without errors.
  </done>
  </task>

<task type="auto">
  <name>Task 2: Property info route and build verification</name>
  <files>
    apps/accommodations/frontend/app/api/stay/[code]/property/route.ts
  </files>
  <action>
**Property route** (`app/api/stay/[code]/property/route.ts`):
- GET handler, requires JWT (same auth guard pattern as Task 1)
- Extract propertyId from verified JWT payload
- Query Supabase:
  ```
  supabase.from('accom_properties')
    .select(`
      id, name, slug, type, description, address, city, area, country,
      contact_phone, contact_whatsapp, contact_email,
      check_in_time, checkout_time, house_rules, amenities,
      images, cover_image, rating, review_count,
      wifi_network, wifi_password
    `)
    .eq('id', propertyId)
    .single()
  ```
- Map to PropertyInfo type (camelCase). house_rules and amenities are Postgres TEXT arrays (string[]).
- Include WiFi info in the response (WifiInfo nested object)
- Return 200 `{ data: { property, wifi } }`
- If not found (shouldn't happen with valid JWT): return 404 `{ error: 'booking_not_found' }`
- Wrap in try/catch, return 500 on errors

**Build verification:**

- Run `pnpm build --filter @gudbro/accommodations-frontend` to confirm all 5 API routes compile in the Next.js production build
- Fix any type errors that emerge from the build
  </action>
  <verify>
  Run `cd apps/accommodations/frontend && npx tsc --noEmit` — zero errors. Run `pnpm build --filter @gudbro/accommodations-frontend` — build succeeds. Verify all 5 route files exist under app/api/stay/.
  </verify>
  <done>
  GET /api/stay/[code]/property returns property info with contact, house rules, checkout time, and WiFi. Full build passes. All 5 API routes (lookup, verify, services, deals, property) compile and build successfully.
  </done>
  </task>

</tasks>

<verification>
1. `cd apps/accommodations/frontend && npx tsc --noEmit` passes with zero errors
2. `pnpm build --filter @gudbro/accommodations-frontend` succeeds
3. All route files exist:
   - app/api/stay/[code]/route.ts (from 05-01)
   - app/api/stay/verify/route.ts (from 05-01)
   - app/api/stay/[code]/services/route.ts
   - app/api/stay/[code]/deals/route.ts
   - app/api/stay/[code]/property/route.ts
4. All protected routes verify JWT and use propertyId from token payload
5. All responses use { data, error } wrapper format
</verification>

<success_criteria>

- Services route returns nested categories with items, filtered by active status
- Deals route returns partner deals from conventions system linked to property
- Property route returns complete property info including WiFi
- All three routes reject requests without valid JWT (401)
- All three routes use propertyId from JWT, not from URL
- Full Next.js build passes with all 5 API routes
  </success_criteria>

<output>
After completion, create `.planning/phases/05-api-layer/05-02-SUMMARY.md`
</output>
